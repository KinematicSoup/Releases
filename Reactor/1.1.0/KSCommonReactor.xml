<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KSCommonReactor</name>
    </assembly>
    <members>
        <member name="T:KS.Reactor.Client.IChangeEvent">
            <summary>Change event interface</summary>
        </member>
        <member name="M:KS.Reactor.Client.IChangeEvent.Invoke">
            <summary>Invokes the event</summary>
        </member>
        <member name="T:KS.Reactor.Client.PropertyChangeEvent">
            <summary>Property change event</summary>
        </member>
        <member name="M:KS.Reactor.Client.PropertyChangeEvent.#ctor(KS.Reactor.Client.PropertySync,System.UInt32,KS.Reactor.ksMultiType@,KS.Reactor.ksMultiType@)">
            <summary>Constructor</summary>
            <param name="propertySync">Property sync to invoke the event on</param>
            <param name="propertyId">Id of changed property</param>
            <param name="oldValue">Old property value</param>
            <param name="newValue">New property value</param>
        </member>
        <member name="M:KS.Reactor.Client.PropertyChangeEvent.Invoke">
            <summary>Invokes the event</summary>
        </member>
        <member name="T:KS.Reactor.Client.OwnershipChangeEvent">
            <summary>Ownership change event</summary>
        </member>
        <member name="M:KS.Reactor.Client.OwnershipChangeEvent.#ctor(KS.Reactor.Client.ksBaseEntity,System.UInt32,System.UInt32,KS.Reactor.ksOwnerPermissions,KS.Reactor.ksOwnerPermissions)">
            <summary>Constructor</summary>
            <param name="entity">Entity to invoke the event for</param>
            <param name="oldOwnerId">Player id of the old owner</param>
            <param name="newOwnerId">Player id of the new owner</param>
            <param name="oldPermissions">Old owner permissions</param>
            <param name="newPermissions">New owner permissions</param>
        </member>
        <member name="M:KS.Reactor.Client.OwnershipChangeEvent.Invoke">
            <summary>Invokes the event.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ControllerChangeEvent">
            <summary>Controller change event</summary>
        </member>
        <member name="M:KS.Reactor.Client.ControllerChangeEvent.#ctor(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksPlayerController,KS.Reactor.ksPlayerController)">
            <summary>Constructor</summary>
            <param name="entity">Entity to invoke the event for</param>
            <param name="oldController">Old player controller</param>
            <param name="newController">New player controller</param>
        </member>
        <member name="M:KS.Reactor.Client.ControllerChangeEvent.Invoke">
            <summary>Invokes the event.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ConfirmPlayerSpawnEvent">
            <summary>Confirm player spawn event</summary>
        </member>
        <member name="M:KS.Reactor.Client.ConfirmPlayerSpawnEvent.#ctor(KS.Reactor.Client.ksBaseEntity)">
            <summary>Constructor</summary>
            <param name="entity">Entity to invoke the event for.</param>
        </member>
        <member name="M:KS.Reactor.Client.ConfirmPlayerSpawnEvent.Invoke">
            <summary>Invokes the event.</summary>
        </member>
        <member name="T:KS.Reactor.Client.CubicInterpolator`1">
            Generic cubic interpolation that smoothly moves from zero with an initial velocity to a stop at a target value.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.CubicInterpolator`1.#ctor(KS.Reactor.Client.IMath{`0})" -->
        <member name="M:KS.Reactor.Client.CubicInterpolator`1.Init(`0,System.Single)">
            Initializes a cubic curve with initial velocity being the velocity at the time Interpolate was last called.
            You must call this before calling Interpolate.
            
            @param   T target to end interpolation at.
            @param   float duration in seconds to get to the target.
        </member>
        <member name="M:KS.Reactor.Client.CubicInterpolator`1.Interpolate(System.Single)">
            Gets the value at a given time. You must call Init before calling this.
            
            @param   float t - time.
            @return  T interpolated value.
        </member>
        <member name="M:KS.Reactor.Client.CubicInterpolator`1.Finish">
            Finishes interpolation so the next curve will use zero for initial velocity. After this is called,
            you cannot call Interpolate again until Init is called.
        </member>
        <member name="T:KS.Reactor.Client.EntityState">
            <summary>Holds entity state for synced entities. Permanent entities do not have an entity state.</summary>
        </member>
        <member name="T:KS.Reactor.Client.EntityState.States">
            <summary>Entity state states</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.State">
            <summary>State of the entity state.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.DestroyRequested">
            <summary>True if we requested this entity be destroyed.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.Index">
            <summary>
            The index of the entity state in the room's active list. An entity state is active if it has a predictor
            and is moving.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.Id">
            <summary>Entity id</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.SyncGroup">
            <summary>Sync group</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.OwnerId">
            <summary>Player id of the entity's owner. Zero for no owner.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.OwnerPermissions">
            <summary>Owner permission flags</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.SpawnedByLocalPlayer">
            <summary>True if the entity was spawned by the local player.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.ServerTransform">
            <summary>Server transform</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.ClientTransform">
            <summary>
            Client transform. This is null until the first time the entity uses a predictor or is owned by the local 
            player with the transform permission. It will stop updating when there is no predictor and the local player
            is not the owner with the transform permission, and the entity will instead use the server transform.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.Entity">
            <summary>Entity the entity state belongs to.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.Room">
            <summary>Room the entity state is in.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.ServerTeleported">
            <summary>
            Did the server teleport the entity? Set to false after calling
            <see cref="M:KS.Reactor.Client.ksIPredictor.ServerUpdate(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.ClientTeleported">
            <summary>
            Did the local player teleport the entity? The local player can only teleport entities they own with the
            transform permission.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.PropertySync">
            <summary>Property sync.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.PredictedServerStateUpdated">
            <summary>
            True if any server state that is being predicted (transform or properties) was updated. Set to false after
            <see cref="M:KS.Reactor.Client.ksIPredictor.ServerUpdate(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)"/>
            is called. Setting to true will add the entity state to the room's predicting entity states list.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.PredictionEnabled">
            <summary>Is prediction enabled?</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.Predictor">
            <summary>The predictor that smooths the transform and properties for this entity.</summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.IsNonInputPredictorAssigned">
            <summary>
            Is the predictor to use without a controller that uses input prediction assigned? This is false until the
            first time <see cref="P:KS.Reactor.Client.EntityState.NonInputPredictor"/> is accessed, at which point the getter will call
            <see cref="M:KS.Reactor.Client.ksBaseEntity.CreateNonInputPredictor(KS.Reactor.Client.ksIPredictor@)"/> to create one. The purpose of this is
            to never create a <see cref="P:KS.Reactor.Client.EntityState.NonInputPredictor"/> for entities that do not need one, unless the
            <see cref="P:KS.Reactor.Client.EntityState.NonInputPredictor"/> is accessed. This may be true while <see cref="P:KS.Reactor.Client.EntityState.NonInputPredictor"/> is null.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.NonInputPredictor">
            <summary>
            The predictor to use without a controller that uses input prediction. If the setter isn't used, the getter
            will call <see cref="M:KS.Reactor.Client.ksBaseEntity.CreateNonInputPredictor(KS.Reactor.Client.ksIPredictor@)"/> to create a predictor the
            first time it is accessed.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.IsInputPredictorAssigned">
            <summary>
            Is the predictor to use with a controller that uses input prediction assigned? This is false until the first
            time <see cref="P:KS.Reactor.Client.EntityState.InputPredictor"/> is accessed, at which point the getter will call
            <see cref="M:KS.Reactor.Client.ksBaseEntity.CreateInputPredictor(KS.Reactor.Client.ksIPredictor@)"/> to create one.The purpose of this is to
            never create an <see cref="P:KS.Reactor.Client.EntityState.InputPredictor"/> for entities that do not need one, unless the
            <see cref="P:KS.Reactor.Client.EntityState.InputPredictor"/> is accessed.This may be true while <see cref="P:KS.Reactor.Client.EntityState.InputPredictor"/> is null.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.InputPredictor">
            <summary>
            The predictor to use with a controller that uses input prediction. If the setter isn't used, the getter
            will call <see cref="M:KS.Reactor.Client.ksBaseEntity.CreateInputPredictor(KS.Reactor.Client.ksIPredictor@)"/> to create a predictor the first
            time it is accessed.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.EntityState.PlayerController">
            <summary>Player controller</summary>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.#cctor">
            <summary>Static initialization</summary>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.SetServerPosition(KS.Reactor.ksVector3)">
            <summary>Sets the server position.</summary>
            <param name="position">Position to set</param>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.SetServerRotation(KS.Reactor.ksQuaternion)">
            <summary>Sets the server rotation.</summary>
            <param name="rotation">Rotation to set.</param>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.SetServerScale(KS.Reactor.ksVector3)">
            <summary>Sets the server scale.</summary>
            <param name="scale">Scale to set</param>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.PredictorServerUpdate">
            <summary>
            Calls <see cref="M:KS.Reactor.Client.ksIPredictor.ServerUpdate(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)"/>
            on the predictor if <see cref="P:KS.Reactor.Client.EntityState.PredictedServerStateUpdated"/> is true or <see cref="F:KS.Reactor.Client.EntityState.m_skipPredictorServerUpdate"/>
            is false, then sets <see cref="P:KS.Reactor.Client.EntityState.PredictedServerStateUpdated"/> to false.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.PredictorClientUpdate">
            <summary>
            Calls <see cref="M:KS.Reactor.Client.ksIPredictor.ClientUpdate(KS.Reactor.ksTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})"/> on the
            predicto if <see cref="F:KS.Reactor.Client.EntityState.m_skipPredictorClientUpdate"/> is false, then applies the predicted transform and
            properties to the entity.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.UpdateClientTransform">
            <summary>Updates the client entity transform.</summary>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.Destroy(KS.Reactor.Client.ksDestroyReason)">
            <summary>
            Destroys the tracked entity then reset member variables before returning the entity state to an object pool.
            </summary>
            <param name="reason">The reason the entity was destroyed.</param>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.SetController(System.UInt32,System.Boolean)">
            <summary>Creates and sets a new player controller if the controller type changed.</summary>
            <param name="controllerId">
            Controller id. If <paramref name="isAsset"/> is true, this is an asset id, otherwise it is a controller
            type id.
            </param>
            <param name="isAsset">
            If true, the player controller will be loaded by asset id. If false, it loaded by controller type id.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.SetupPredictorTransformState(System.Boolean)">
            <summary>
             Sets up the predictor and entity transform state for the current prediction and ownership state.
              - If prediction is disabled or the entity is owned locally with the transform permission, sets the
                predictor to null.
             - Otherwise if the entity has a player controller, sets the predictor to the input predictor.
             - Otherwise sets the predictor to the non-input predictor.
             - If the entity has no predictor and the entity is not owned locally with the transform permission, sets
                the entity transform to be the same object as the server transform.
             - Otherwise sets the entity transform to the client transform state object.
            </summary>
            <param name="gainedTransformOwnership">
            True if the local player gained ownership of the transform. If true, sets dirty flags for client transform
            values that are different from the server values to ensure they are sent in the first update.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.SetOwner(System.UInt32,KS.Reactor.ksOwnerPermissions)">
            <summary>Sets the owner and permissions.</summary>
            <param name="ownerId">Owner id to set</param>
            <param name="permissions">Permissions to set</param>
            <returns>True if the local player gained transform ownership and the entity state is linked to an entity.</returns>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.SetPredictor(KS.Reactor.Client.ksIPredictor)">
            <summary>Sets the predictor for smoothing motion and properties of this entity state.</summary>
            <param name="predictor">Predictor to set.</param>
            <returns>True if the predictor was changed to the given <paramref name="predictor"/>.</returns>
        </member>
        <member name="M:KS.Reactor.Client.EntityState.ClearNonPredictedControllerProperties">
            <summary>Clears controller property values for properties that are not predicted.</summary>
        </member>
        <member name="T:KS.Reactor.Client.IMath`1">
            Templated interface for basic math operations.
        </member>
        <member name="P:KS.Reactor.Client.IMath`1.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.IMath`1.Add(`0,`0)">
            Addition
            
            @param   T lhs
            @param   T rhs
            @return  T lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.IMath`1.Subtract(`0,`0)">
            Subtraction
            
            @param   T lhs
            @param   T rhs
            @return  T lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.IMath`1.Multiply(`0,System.Single)">
            Scalar multiplication
            
            @param   T value
            @param   T scalar
            @return  T value * scalar
        </member>
        <member name="T:KS.Reactor.Client.FloatMath">
            float math operations
        </member>
        <member name="P:KS.Reactor.Client.FloatMath.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.FloatMath.Add(System.Single,System.Single)">
            float addition
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.FloatMath.Subtract(System.Single,System.Single)">
            float subtraction
            
            @param   float lhs
            @param   float rhs
            @return  float lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.FloatMath.Multiply(System.Single,System.Single)">
            float multiplication
            
            @param   float value
            @param   float scalar
            @return  float value * scalar
        </member>
        <member name="T:KS.Reactor.Client.Vector2Math">
            ksVector2 math operations
        </member>
        <member name="P:KS.Reactor.Client.Vector2Math.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.Vector2Math.Add(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            ksVector2 addition
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector2Math.Subtract(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            ksVector2 subtraction
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector2Math.Multiply(KS.Reactor.ksVector2,System.Single)">
            ksVector2 scalar multiplication
            
            @param   ksVector2 value
            @param   float scalar
            @return  ksVector2 value * scalar
        </member>
        <member name="T:KS.Reactor.Client.Vector3Math">
            ksVector3 math operations
        </member>
        <member name="P:KS.Reactor.Client.Vector3Math.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.Vector3Math.Add(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            ksVector3 addition
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector3Math.Subtract(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            ksVector3 subtraction
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector3Math.Multiply(KS.Reactor.ksVector3,System.Single)">
            ksVector3 scalar multiplication
            
            @param   ksVector3 value
            @param   float scalar
            @return  ksVector3 value * scalar
        </member>
        <member name="T:KS.Reactor.Client.ISpace`2">
            Templated interface for defining a mathematical space with the following operations:
            
             Vector + Delta = Vector
             Vector - Vector = Delta
             Delta * float = Delta
             Delta + Delta = Delta (may not be commutative)
             Magnitude(Delta - Delta) = float
        </member>
        <member name="P:KS.Reactor.Client.ISpace`2.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Add(`0,`1)">
            Addition
            
            @param   Vector lhs
            @param   Delta rhs
            @return  Vector lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Subtract(`0,`0)">
            Subtraction
            
            @param   Vector lhs
            @param   Vector rhs
            @return  Delta lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Multiply(`1,System.Single)">
            Scalar multiplication
            
            @param   Delta lhs
            @param   float rhs
            @return  Delta lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.AddDeltas(`1,`1)">
            Delta addition. May not be commutative.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  Delta lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Magnitude(`1)">
            Gets the magnitude of a delta.
            
            @param   Delta delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.CompareDeltas(`1,`1)">
            Gets the magnitude of the difference between two deltas.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Interpolate(`0,`0,System.Single)">
            Interpolates between two vectors.
            
            @param   Vector from - vector to interpolate from.
            @param   Vector to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  Vector
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.MoveTowards(`0,`0,System.Single)">
            Moves a Vector towards another.
            
            @param    Vector start point.
            @param    Vector target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   Vector
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.AreEqual(`0,`0)">
            Check if two Vectors are equal.
            
            @param   Vector a
            @param   Vector b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.IsZero(`1)">
            Check if a delta is the zero delta.
            
            @param   Delta delta
            @return  bool true if the delta is zero.
        </member>
        <member name="T:KS.Reactor.Client.OneSpace">
            1D float math.
        </member>
        <member name="P:KS.Reactor.Client.OneSpace.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Add(System.Single,System.Single)">
            Addition
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Subtract(System.Single,System.Single)">
            Subtraction
            
            @param   float lhs
            @param   float rhs
            @return  float lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Multiply(System.Single,System.Single)">
            Multiplication
            
            @param   float lhs
            @param   float rhs
            @return  float lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.AddDeltas(System.Single,System.Single)">
            Delta addition.
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Magnitude(System.Single)">
            Gets the magnitude of a float.
            
            @param   float delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.CompareDeltas(System.Single,System.Single)">
            Gets the magnitude of the difference between two deltas.
            
            @param   float lhs
            @param   float rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Interpolate(System.Single,System.Single,System.Single)">
            Linearly interpolates between two floats.
            
            @param   float from - value to interpolate from.
            @param   float to - value to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  float
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.MoveTowards(System.Single,System.Single,System.Single)">
            Moves a float towards another.
            
            @param    float start value.
            @param    float target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   float
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.AreEqual(System.Single,System.Single)">
            Check if two floats are equal.
            
            @param   float a
            @param   float b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.IsZero(System.Single)">
            Check if a float is zero.
            
            @param   float delta
            @return  bool true if the float is zero.
        </member>
        <member name="T:KS.Reactor.Client.TwoSpace">
            2D space
        </member>
        <member name="P:KS.Reactor.Client.TwoSpace.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Add(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Addition
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Subtract(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Subtraction
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Multiply(KS.Reactor.ksVector2,System.Single)">
            Scalar multiplication
            
            @param   ksVector2 lhs
            @param   float rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.AddDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Delta addition.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Magnitude(KS.Reactor.ksVector2)">
            Gets the magnitude of a ksVector2.
            
            @param   ksVector2 delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.CompareDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Interpolate(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Linearly interpolates between two vectors.
            
            @param   ksVector2 from - vector to interpolate from.
            @param   ksVector2 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector2
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.MoveTowards(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Moves a ksVector2 towards another.
            
            @param    ksVector2 start point.
            @param    ksVector2 target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector2
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.AreEqual(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Check if two ksVector2s are equal.
            
            @param   ksVector2 a
            @param   ksVector2 b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.IsZero(KS.Reactor.ksVector2)">
            Check if a ksVector2 is zero.
            
            @param   ksVector2 delta
            @return  bool true if the ksVector2 is zero.
        </member>
        <member name="T:KS.Reactor.Client.ThreeSpace">
            3D space
        </member>
        <member name="P:KS.Reactor.Client.ThreeSpace.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Add(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Addition
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Subtract(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Subtraction
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Multiply(KS.Reactor.ksVector3,System.Single)">
            Scalar multiplication
            
            @param   ksVector3 lhs
            @param   float rhs
            @return  ksVector3 lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.AddDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Delta addition.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Magnitude(KS.Reactor.ksVector3)">
            Gets the magnitude of a ksVector3.
            
            @param   ksVector3 delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.CompareDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Interpolate(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Linearly interpolates between two vectors.
            
            @param   ksVector3 from - vector to interpolate from.
            @param   ksVector3 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.MoveTowards(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Moves a ksVector3 towards another.
            
            @param    ksVector3 start point.
            @param    ksVector3 target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector3
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.AreEqual(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Check if two ksVector3s are equal.
            
            @param   ksVector3 a
            @param   ksVector3 b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.IsZero(KS.Reactor.ksVector3)">
            Check if a ksVector3 is zero.
            
            @param   ksVector3 delta
            @return  bool true if the ksVector3 is zero.
        </member>
        <member name="T:KS.Reactor.Client.ColorSpace">
            Color space
        </member>
        <member name="P:KS.Reactor.Client.ColorSpace.Zero">
            Zero color
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Add(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Addition
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  ksColor lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Subtract(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Subtraction
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  ksColor lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Multiply(KS.Reactor.ksColor,System.Single)">
            Scalar multiplication
            
            @param   ksColor lhs
            @param   float rhs
            @return  ksColor lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.AddDeltas(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Delta addition.
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  ksColor lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Magnitude(KS.Reactor.ksColor)">
            Gets the magnitude of a ksColor.
            
            @param   ksColor delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.CompareDeltas(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Interpolate(KS.Reactor.ksColor,KS.Reactor.ksColor,System.Single)">
            Linearly interpolates between two colors.
            
            @param   ksColor from - ksColor to interpolate from.
            @param   ksColor to - ksColor to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksColor
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.MoveTowards(KS.Reactor.ksColor,KS.Reactor.ksColor,System.Single)">
            Moves a ksColor towards another.
            
            @param    ksColor start color.
            @param    ksColor target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksColor
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.AreEqual(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Check if two ksColors are equal.
            
            @param   ksColor a
            @param   ksColor b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.IsZero(KS.Reactor.ksColor)">
            Check if a ksColor is zero.
            
            @param   ksColor delta
            @return  bool true if the ksColor is zero.
        </member>
        <member name="T:KS.Reactor.Client.RangeSpace">
            Finite 1D space that wraps around.
        </member>
        <member name="P:KS.Reactor.Client.RangeSpace.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.#ctor(System.Single,System.Single)">
            Constructor
            
            @param   float min value in the range (inclusive).
            @param   float max value in the range (exclusive).
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Add(System.Single,System.Single)">
            Addition
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Subtract(System.Single,System.Single)">
            Subtraction
            
            @param   float lhs
            @param   float rhs
            @return  float lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Multiply(System.Single,System.Single)">
            Multiplication
            
            @param   float lhs
            @param   float rhs
            @return  float lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.AddDeltas(System.Single,System.Single)">
            Delta addition.
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Magnitude(System.Single)">
            Gets the magnitude of a float.
            
            @param   float delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.CompareDeltas(System.Single,System.Single)">
            Gets the magnitude of the difference between two deltas.
            
            @param   float lhs
            @param   float rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Interpolate(System.Single,System.Single,System.Single)">
            Spherically interpolates between two floats.
            
            @param   float from - value to interpolate from.
            @param   float to - value to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  float
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.MoveTowards(System.Single,System.Single,System.Single)">
            Moves a float towards another.
            
            @param    float start value.
            @param    float target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   float
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.SetRange(System.Single,System.Single)">
            Change the min and max range
            
            @param   float min
            @param   float max
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.AreEqual(System.Single,System.Single)">
            Check if two wrapped floats are equal.
            
            @param   ksColor a
            @param   ksColor b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.IsZero(System.Single)">
            Check if a float is zero.
            
            @param   float delta
            @return  bool true if the float is zero.
        </member>
        <member name="T:KS.Reactor.Client.CircleSpace">
            2D space with spherical interpolation.
        </member>
        <member name="P:KS.Reactor.Client.CircleSpace.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Add(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Addition
            
            @param   ksVector2 direction
            @param   ksVector2 delta (x = delta radians, y = delta magnitude)
            @return  direction + delta
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Subtract(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Subtraction
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 delta (x = delta radians, y = delta magnitude)
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Multiply(KS.Reactor.ksVector2,System.Single)">
            Scalar multiplication
            
            @param   ksVector2 lhs
            @param   float rhs
            @return  ksVector2 lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.AddDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Delta addition.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Magnitude(KS.Reactor.ksVector2)">
            Gets the magnitude of a delta.
            
            @param   ksVector2 delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.CompareDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Interpolate(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Spherically interpolates between two vectors.
            
            @param   ksVector2 from - vector to interpolate from.
            @param   ksVector2 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector2
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.MoveTowards(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Rotates a ksVector2 towards another.
            
            @param    ksVector2 start point.
            @param    ksVector2 target to move towards.
            @param    float amount to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector2
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.AreEqual(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Check if two ksVector2s are equal.
            
            @param   ksVector2 a
            @param   ksVector2 b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.IsZero(KS.Reactor.ksVector2)">
            Check if a ksVector2 is zero.
            
            @param   ksVector2 delta
            @return  bool true if the ksVector2 is zero.
        </member>
        <member name="T:KS.Reactor.Client.SphereSpace">
            3D space with spherical interpolation.
        </member>
        <member name="T:KS.Reactor.Client.SphereSpace.Delta">
            Spherical delta
        </member>
        <member name="F:KS.Reactor.Client.SphereSpace.Delta.Angular">
            Delta angular in radians.
        </member>
        <member name="F:KS.Reactor.Client.SphereSpace.Delta.Magnitude">
            Delta magnitude
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Delta.Serialize(KS.Reactor.ksStreamBuffer)">
            Serializes to a buffer.
            
            @param   ksStreamBuffer buffer
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Delta.Deserialize(KS.Reactor.ksStreamBuffer)">
            Deserializes from a buffer.
            
            @param   ksStreamBuffer buffer
        </member>
        <member name="P:KS.Reactor.Client.SphereSpace.Zero">
            Zero delta
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Add(KS.Reactor.ksVector3,KS.Reactor.Client.SphereSpace.Delta)">
            Addition
            
            @param   ksVector3 direction
            @param   Delta delta
            @return  direction + delta
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Subtract(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Subtraction
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  Delta lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Multiply(KS.Reactor.Client.SphereSpace.Delta,System.Single)">
            Scalar multiplication
            
            @param   Delta delta
            @param   float scalar
            @return  delta * scalar
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.AddDeltas(KS.Reactor.Client.SphereSpace.Delta,KS.Reactor.Client.SphereSpace.Delta)">
            Delta addition. Non-commutative.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  Delta lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Magnitude(KS.Reactor.Client.SphereSpace.Delta)">
            Gets the magnitude of a delta.
            
            @param   Delta delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.CompareDeltas(KS.Reactor.Client.SphereSpace.Delta,KS.Reactor.Client.SphereSpace.Delta)">
            Gets the magnitude of the difference between two deltas.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Interpolate(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Spherically interpolates between two vectors.
            
            @param   ksVector3 from - vector to interpolate from.
            @param   ksVector3 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.MoveTowards(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Rotates a ksVector3 towards another.
            
            @param    ksVector3 start point.
            @param    ksVector3 target to move towards.
            @param    float amount to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector3
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.AreEqual(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Check if two ksVector3s are equal.
            
            @param   ksVector3 a
            @param   ksVector3 b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.IsZero(KS.Reactor.Client.SphereSpace.Delta)">
            Check if a Delta is zero.
            
            @param   Delta delta
            @return  bool true if the Delta is zero.
        </member>
        <member name="T:KS.Reactor.Client.RotationSpace">
            Rotation space
        </member>
        <member name="P:KS.Reactor.Client.RotationSpace.Zero">
            Zero angular displacement
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Add(KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            Addition
            
            @param   ksQuaternion rotation
            @param   ksVector3 angularDisplacement
            @return  ksQuaternion rotation + angularDisplacement
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Subtract(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            Subtraction
            
            @param   ksQuaternion lhs
            @param   ksQuaternion rhs
            @return  ksVector3 angular displacement from rhs to lhs.
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Multiply(KS.Reactor.ksVector3,System.Single)">
            Scalar multiplication
            
            @param   ksVector3 lhs
            @param   float rhs
            @return  ksVector3 lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.AddDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Delta addition. Non-commutative.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Magnitude(KS.Reactor.ksVector3)">
            Gets the magnitude of a ksVector3.
            
            @param   ksVector3 delta
            @return  float magnitude
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.CompareDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Interpolate(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            Spherically interpolates between two quaternions.
            
            @param   ksQuaternion from - quaternion to interpolate from.
            @param   ksQuaternion to - quaternion to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksQuaternion
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.MoveTowards(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            Rotates a quaternion towards another.
            
            @param    ksQuaternion start quaternion.
            @param    ksQuaternion target to move towards.
            @param    float degrees to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksQuaternion
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.AreEqual(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            Check if two ksQuaternions are equal.
            
            @param   ksQuaternion a
            @param   ksQuaternion b
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.IsZero(KS.Reactor.ksVector3)">
            Check if a ksVector3 is zero.
            
            @param   ksVector3 delta
            @return  bool true if the ksVector3 is zero.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity">
            <summary>
            Base class for entities. Entities are objects controlled by the server and replicated to clients.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.RPCHandler">
            <summary>RPC event handler.</summary>
            <param name="arguments">arguments from the server.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.ControllerChangeHandler">
            <summary>Controller change handler.</summary>
            <param name="oldController"></param>
            <param name="newController"></param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.OwnershipChangeHandler">
            <summary>Ownership change handler.</summary>
            <param name="oldOwnerId">Old owner id</param>
            <param name="newOwnerId">New owner id</param>
            <param name="oldPermissions">Old permissions</param>
            <param name="newPermissions">New permissions</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.ConfirmPlayerSpawnHandler">
            <summary>Confirm player spawn handler</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.DestroyHandler">
            <summary>Destroy event handler.</summary>
            <param name="reason">The reason the entity was destroyed.</param>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.OnPropertyChange">
            <summary>Invoked when an entity property changes. Indexed by property id.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.OnRPC">
            <summary>Invoked when the server calls an RPC on the room. Indexed by RPC id.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseEntity.OnControllerChange">
            <summary>Invoked when the player controller changes.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.HasControllerChangeHandler">
            <summary>True if <see cref="E:KS.Reactor.Client.ksBaseEntity.OnControllerChange"/> has any handlers registered.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseEntity.OnOwnershipChange">
            <summary>Invoked when the owner or owner permissions change.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.HasOwnershipChangeHandler">
            <summary>True if <see cref="E:KS.Reactor.Client.ksBaseEntity.OnOwnershipChange"/> has any handlers registered.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseEntity.OnConfirmPlayerSpawn">
            <summary>
            Invoked when an entity spawned by the local player is confirmed as spawned by the server.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.HasConfirmPlayerSpawnHandler">
            <summary>True if <see cref="E:KS.Reactor.Client.ksBaseEntity.OnConfirmPlayerSpawn"/> has any handlers registered.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseEntity.OnDestroy">
            <summary>Invoked when the entity is destroyed.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Id">
            <summary>Entity id</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Type">
            <summary>Entity type</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.AssetId">
            <summary>Entity asset id.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.SyncGroup">
            <summary>
            The sync group the entity belongs to. Players can only see entities in sync groups they are added to.
            Entities in sync group zero are always visible.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.OwnerId">
            <summary>The id of the player who owns this entity.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.OwnerPermissions">
            <summary>Owner permission flags.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsOwner">
            <summary>Does the local player own this entity?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Parent">
            <summary>
            Get/Set a parent entity to this entity.
            If the new value is a descendant of this entity, then the parent will not be updated.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Children">
            <summary>
            List of the child entities attached to this entity.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.AddChild(KS.Reactor.Client.ksBaseEntity)">
            <summary>
            Add a child to the list of children attached to this entity.
            </summary>
            <param name="child">Child entity.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.RemoveChild(KS.Reactor.Client.ksBaseEntity)">
            <summary>
            Remove a child entity from the list of children.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.RemoveAllChildren">
            <summary>
            Remove all children from the entity.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.HasDescendant(KS.Reactor.Client.ksBaseEntity)">
            <summary>
            Check if an entity has another entity as one of its descendants.
            </summary>
            <param name="child">Entity to search for.</param>
            <returns>True if the entity is a descendant of this entity.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.ForEachDescendant(System.Action{KS.Reactor.Client.ksBaseEntity})">
            <summary>
            Iterate all descendants and invoke a callback with each.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.UseControllerTransform">
            <summary>
            If true, <see cref="P:KS.Reactor.Client.ksBaseEntity.Transform"/> points to the player controller's transform instead of the entity
            transform. This is true when predictors update so Entity.Transform and Controller.Transform are the same
            while updating controllers.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Index">
            <summary>Index of the entity in the room's dynamic entity list. -1 If not in the list.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Transform">
            <summary>Client transform.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Transform2D">
            <summary>2D client transform.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerTransform">
            <summary>Server transform.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerTransform2D">
            <summary>2D representation of the server transform.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Properties">
            <summary>Entity properties</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.PredictionEnabled">
            <summary>Is prediction enabled?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Predictor">
            <summary>
            The predictor that is currently smoothing the transform and properties for the entity. To change the
            predictor, set either <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> or <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsNonInputPredictorAssigned">
            <summary>
            Is the predictor to use without a controller that uses input prediction assigned? This is false until the
            first time <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> is accessed, at which point the getter will call
            <see cref="M:KS.Reactor.Client.ksBaseEntity.CreateNonInputPredictor(KS.Reactor.Client.ksIPredictor@)"/> to create one.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor">
            <summary>
            The predictor to use when the entity does not have a player controller with input prediction enabled.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsInputPredictorAssigned">
            <summary>
            Is the predictor to use with a controller that uses input prediction assigned? This is false until the first
            time <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/> is accessed, at which point the getter will call
            <see cref="M:KS.Reactor.Client.ksBaseEntity.CreateInputPredictor(KS.Reactor.Client.ksIPredictor@)"/> to create one.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.InputPredictor">
            <summary>The predictor to use when the entity has a player controller with input enabled.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.RigidBody">
            <summary>The entity's rigid body. Null if the entity does not have a rigid body.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.RigidBody2D">
            <summary>The entity's 2D rigid body. Null if the entity does not have a 2D rigid body.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.CharacterController">
            <summary>Character controller.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.PlayerController">
            <summary>Player controller controlling this entity.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsPermanent">
            <summary>
            Is this a permanent entity? Permanent entities never move and cannot be destroyed. They are not synced to
            clients since the clients should already know where they are.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.CollisionFilter">
            <summary>Determines which entities to collide with and notify of collision/overlap events.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.PropertySync">
            <summary>PropertySync</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsWaitingForPlayerSpawnResponse">
            <summary>
            True if the entity was spawned by the local player and we are waiting for the server to confirm or deny
            the spawn request.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.SpawnedByLocalPlayer">
            <summary>True if the entity was spawned by the local player.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsDestroyed">
            <summary>Is the entity destroyed?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsDestroyedLocally">
            <summary>
            Is the entity destroyed locally? Derived classes should implement this. If it returns true and the local
            player owns the entity with the <see cref="F:KS.Reactor.ksOwnerPermissions.DESTROY"/> permission, a request will be sent
            to the server to destroy the entity.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.LocalOwnerTeleported">
            <summary>
            Does the local player own this entity with the transform permission and did they teleport it? Setting does
            nothing if the local player does not own the entity with the transform permission. This gets reset to false
            after entity updates are sent to the server.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.BaseRoom">
            <summary>Room the entity is in.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.EntityState">
            <summary>Carries entity state for synced entities. This is null for permanent entities.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.Initialize(KS.Reactor.ksEntityId,System.UInt32,KS.Reactor.ksTransformState,KS.Reactor.Client.ksBaseRoom,KS.Reactor.ksSpawnParams)">
            <summary>Initializes the entity.</summary>
            <param name="entityId">Entity id</param>
            <param name="assetId">Asset id</param>
            <param name="transform">Entity transform</param>
            <param name="room">Room the entity belongs to.</param>
            <param name="spawnParams">
            If the entity was spawned by the local player, this is the spawn parameters object used to spawn the
            entity, otherwise it is null.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.Initialize(KS.Reactor.ksSpawnParams)">
            <summary>
            Implement this to initialize data for your entity. This is called after the initial server data for the
            entity is synced, which includes the entity id, asset id, transform, player controller, and properties. The
            default implementation does nothing.
            </summary>
            <param name="spawnParams">
            If the entity was spawned by the local player, this is the spawn parameters object used to spawn the
            entity, otherwise it is null.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.CleanUp">
            <summary>Cleanup the object for reuse.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.UpdatePosition">
            <summary>Use this to apply position changes to the game state.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.UpdateRotation">
            <summary>Use this to apply rotation changes to the game state.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.UpdateScale">
            <summary>Use this to apply scale changes to the game state.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.UpdateEntityTransform">
            <summary>
            Calls <see cref="M:KS.Reactor.Client.ksBaseEntity.GetTransformUpdate(KS.Reactor.ksTransformState)"/> to update the <see cref="P:KS.Reactor.Client.ksBaseEntity.Transform"/> if the local
            player owns the entity with the transform permission. Normally you should not need to call this, as 
            <see cref="M:KS.Reactor.Client.ksBaseEntity.GetTransformUpdate(KS.Reactor.ksTransformState)"/> is called automatically for owned entities with the 
            transform permission before the client sends entity updates to the server. Calling this will not make the
            entity update sent sooner. It can be used to force the call to happen early if needed, such as when a game
            object is being destroyed and we need to get the final transform data from it before it is destroyed.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.GetTransformUpdate(KS.Reactor.ksTransformState)">
            <summary>
            Gets an updated transform to send to the server. This is called on locally-owned entities with the
            <see cref="F:KS.Reactor.ksOwnerPermissions.TRANSFORM"/> permission. You must implement this to get transform state from
            the game state and apply it to <paramref name="transform"/>. If you set a value on
            <paramref name="transform"/>, it will set a dirty flag for that value and generate an update to send to the
            server, even if that value did not change. You should check if the value changed before setting a value.
            </summary>
            <param name="transform">Transform to update.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.CreateNonInputPredictor(KS.Reactor.Client.ksIPredictor@)">
            <summary>
            Creates a predictor to use when the entity does not have a player controller with input prediction enabled.
            </summary>
            <param name="predictor">The predictor created.</param>
            <returns>False if the predictor could not be created.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseEntity.CreateInputPredictor(KS.Reactor.Client.ksIPredictor@)" -->
        <member name="M:KS.Reactor.Client.ksBaseEntity.CallRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Calls an RPC on this entity on the server.</summary>
            <param name="rpcId">rpcId of rpc to call.</param>
            <param name="arguments">arguments to send to server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.AttachScripts">
            <summary>Attaches entity scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InitializeScripts">
            <summary>Initializes entity scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.Destroy(KS.Reactor.Client.ksDestroyReason)">
            <summary>Destroys the entity.</summary>
            <param name="reason">The reason the entity was destroyed.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Invoke managed RPCs on all entity scripts.</summary>
            <param name="rpcId">RPC ID</param>
            <param name="rpcArgs">RPC arguments</param>
            <returns>True if the method invoked any RPC handler</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.OwnershipChanged">
            <summary>
            Called when owner id or owner permissions change. Derived classes can implement this to take action when
            ownership changes. The default implementation does nothing.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InvokeOwnershipChange(System.UInt32,System.UInt32,KS.Reactor.ksOwnerPermissions,KS.Reactor.ksOwnerPermissions)">
            <summary>Invokes the <see cref="E:KS.Reactor.Client.ksBaseEntity.OnOwnershipChange"/> event.</summary>
            <param name="oldOwnerId">Old owner id</param>
            <param name="newOwnerId">New owner id</param>
            <param name="oldPermissions">Old permissions</param>
            <param name="newPermissions">New permissions</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.PlayerSpawnConfirmed">
            <summary>
            Called when an entity spawned by the local player is confirmed as spawned by the server. Derived classes
            can implement this to take action when a spawn is confirmed. The default implementation does nothing.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InvokeConfirmPlayerSpawn">
            <summary>Invokes the <see cref="E:KS.Reactor.Client.ksBaseEntity.OnConfirmPlayerSpawn"/> event.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InvokeDestroy(KS.Reactor.Client.ksDestroyReason)">
            <summary>Invokes the on destroy event.</summary>
            <param name="reason">The reason the entity was destroyed.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.ExecuteRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Invokes an <see cref="P:KS.Reactor.Client.ksBaseEntity.OnRPC"/> event.</summary>
            <param name="rpcID">rpcID of rpc to invoke.</param>
            <param name="arguments">arguments from the server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.RegisterRPC(System.UInt32,KS.Reactor.Client.ksBaseEntity.RPCHandler)">
            <summary>Register an RPC</summary>
            <param name="rpcId">RPC Id</param>
            <param name="rpcHandler">RPC handler</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.UnregisterRPC(System.UInt32,KS.Reactor.Client.ksBaseEntity.RPCHandler)">
            <summary>Unregister an RPC</summary>
            <param name="rpcId">RPC Id</param>
            <param name="rpcHandler">RPC handler</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.HasOwnerPermission(KS.Reactor.ksOwnerPermissions)">
            <summary>
            Checks if the local player owns the entity and has any of the <paramref name="permissions"/>.
            </summary>
            <param name="permissions">Permissions to check for.</param>
            <returns>
            True if the local player owns the entity and has any of the <paramref name="permissions"/>.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.GetPropertyServerValue(System.UInt32)">
            <summary>
            Gets property server value. If a property id is not in the map,
            a <see cref="T:KS.Reactor.ksMultiType"/> of type <see cref="F:KS.Reactor.ksMultiType.Types.NULL"/> is returned.
            </summary>
            <param name="propertyId"></param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.Client.ksBasePlayer">
            <summary>Base class for players. A player represents a client.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBasePlayer.LeaveHandler">
            <summary>Leave event handler.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBasePlayer.OnLeave">
            <summary>Invoked when the (non-local) player leaves the room.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.OnPropertyChange">
            <summary>
            Invoked when a player property changes. Indexed by property id. Other properties are not guaranteed to be
            updated when this fires.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBasePlayer.m_propertySync">
            <summary>Property sync</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.Properties">
            <summary>Properties</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.Predictor">
            <summary>Predictor for player properties.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBasePlayer.m_isLocal">
            <summary>Is this the local player?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.Id">
            <summary>Id of the player.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.#ctor(System.UInt32)">
            <summary>Constructor</summary>
            <param name="id">id of the player.</param>
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.BaseRoom">
            <summary>Room the player is in.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.InitializeScripts">
            <summary>Initializes player scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.Destroy">
            <summary>Destroys the player.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.CleanUp">
            <summary>Performs clean up. Called after the player is destroyed.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.InvokeOnLeave">
            <summary>Invokes the <see cref="E:KS.Reactor.Client.ksBasePlayer.OnLeave"/> event.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.GetPropertyServerValue(System.UInt32)">
            <summary>
            Gets property server value. If a property id is not in the map,
            a <see cref="T:KS.Reactor.ksMultiType"/> of type <see cref="F:KS.Reactor.ksMultiType.Types.NULL"/> is returned.
            </summary>
            <param name="propertyId"></param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom">
            <summary>
            Base class for rooms. Rooms are used to connect to server rooms.
            The room maintains simulation state that is regularly synced with the server.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.MIN_SEND_RATE">
            <summary>Minimum <see cref="P:KS.Reactor.Client.ksBaseRoom`2.SendRate"/> value.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.MAX_SEND_RATE">
            <summary>Maximum <see cref="P:KS.Reactor.Client.ksBaseRoom`2.SendRate"/> value.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.ConnectStatus">
            <summary>Connect/disconnect status.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.SUCCESS">
            <summary>A connection process completed successfuly</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.TIMEOUT">
            <summary>The connection timed out, or the connected host has failed to respond.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.ABORTED">
            <summary>The connection was aborted by the client or socket provider.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.REFUSED">
            <summary>The remote host is actively refusing a connection.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.RESET">
            <summary>The connection was reset by the remote host.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.UNSUPPORTED_PROTOCOL">
            <summary>No connection factory for the configured room protocol exists.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.ROOM_INITIALIZE_ERROR">
            <summary>The room associated with the connection attempt failed to initialize.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.INVALID_ADDRESS">
            <summary>
            The <see cref="T:KS.Reactor.ksRoomInfo"/> does not have a valid address set for the selected protocol.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.AUTH_ERR_USER_DEFINED">
            <summary>Custom error status returned by user-defined authentication function."/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.AUTH_ERR_INVALID_PROTOCOL">
            <summary>Reactor protocol mismatch.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.AUTH_ERR_CONNECTION_LIMIT">
            <summary>Reactor connection limit reached</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.AUTH_ERR_TIMEOUT">
            <summary>A user-defined authentication function timed out.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.AUTH_ERR_UNKNOWN">
            <summary>
            An unknown authentication error occurred, such as a user-defined authentication function throwing an
            exception.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.GET_ROOMS_ERROR">
            <summary>An error occured while attempting to get a list of rooms.</summary> 
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.ConnectStatus.UNKNOWN_ERROR">
            <summary>Unknown error</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.ConnectEvent">
            <summary>Information about a connection event</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.DisconnectEvent">
            <summary>Information about a disconnection event</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.PlayerTime">
            <summary>
            Time object for a player who owns entities with the transform permission.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.PlayerTime.Index">
            <summary>The index of this object in the player time list. -1 if it's not in the list.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.PlayerTime.ObjectCount">
            <summary>
            The number of entities the player owns with the transform permission. The player time object will be
            removed if this reaches zero.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.PlayerTime.#ctor(System.UInt32)">
            <summary>Constructor</summary>
            <param name="playerId">Id of the player this time object is for.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.StateChangeHandler">
            <summary>Handler called when the room connection state changes.</summary>
            <param name="room">Room whose state changed</param>
            <param name="status">New room status</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.ConnectHandler">
            <summary>Connect status event handler. </summary>
            <param name="status">status of the connection.</param>
            <param name="result">Result from user-defined authentication functions.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.DisconnectHandler">
            <summary>Disconnect status event handler. </summary>
            <param name="status">status of the connection.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.RPCHandler">
            <summary>RPC event handler.</summary>
            <param name="arguments">arguments from the server.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.InputUpdateHandler">
            <summary>Input update handler.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.SendFrameHandler">
            <summary>Send client frame handler.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom.OnStateChange">
            <summary>Events called when the connection state changes.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.ConnectionState">
            <summary>Get the connection state of the room. </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Id">
            <summary>Room id</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Address">
            <summary>
            The host and port for the room. May change depending on the protocol selected.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Info">
            <summary>Room info</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Time">
            <summary>Server time and local frame delta.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Physics">
            <summary>Physics API</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsConnecting">
            <summary>Are we in the process of establishing a connection with the server?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsConnected">
            <summary>Are we connected to the server?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsDisconnecting">
            <summary>Are we disconnecting from the server?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.SuppressCannotCallRPCWarning">
            <summary>Should we suppress "Cannot call RPC" warnings when disconnected or disconnecting?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.LocalPlayerId">
            <summary>The local player id.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.InputAcknowledged">
            <summary>Has the server acknowledged receiving our first input?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.InputRegistrar">
            <summary>Input registrar</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.InputManager">
            <summary>Input manager</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Input">
            <summary>Input</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.PlayerTimeAdjusterFactory">
            <summary>Factory for creating player time adjusters.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.PropertySync">
            <summary>Property sync</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Gravity">
            <summary>Gravity</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ApplyServerTimeScale(System.Single)">
            <summary>Apply server time scale to the client.</summary>
            <param name="timeScale"></param>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.RPCLatency">
            <summary>RPC Latency in milliseconds</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Latency">
            <summary>Latency in milliseconds</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.ServerEvents">
            <summary>Server event list</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.ChangeEvents">
            <summary>
            Change event queue. Change events are queued during server frame processing, and invoked once processing is
            completed so that all changes are applied when the events fire.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.QueueUpdate(KS.Reactor.Secret.RoomUpdate)">
            <summary>Queues a room update.</summary>
            <param name="update">Update to queue.</param>
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.m_connectionFactories">
            <summary>Connection factories</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.GetTime(System.UInt32)">
            <summary>
            Gets a player's time object. Each player who owns entities with the transform permission has time a time
            object that tracks their timing data which can be used to smooth motion for the entities they control.
            </summary>
            <param name="playerId">Id of player to get the time object for. If zero, gets <see cref="P:KS.Reactor.Client.ksBaseRoom.Time"/>.</param>
            <returns>
            The time object for the player, or <see cref="P:KS.Reactor.Client.ksBaseRoom.Time"/> if <paramref name="playerId"/> was zero, or null if
            the player has no owned entities with the transform permission.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.GetEntityState(KS.Reactor.ksEntityId)">
            <summary>Gets an entity state by id.</summary>
            <param name="entityId">Id of entity to get entity state for.</param>
            <returns>Entity state, or null if none was found.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.Connect(KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[])">
            <summary>Connects to the server.</summary>
            <param name="session">player session</param>
            <param name="authArgs">authentication arguments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.Disconnect(System.Boolean)">
            <summary>Disconnects from the server.</summary>
            <param name="immediate">if false, waits for pending writes before disconnecting.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DiagnoseConnectionFailure">
            <summary>Diagnose Connection Failure to the server.</summary>
            <returns>error message</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.Update(System.Single,System.Single)">
            <summary>Updates the room. Syncs properties from the server and updates scripts.</summary>
            <param name="unscaledDeltaTime">
            Time delta since the last update in seconds of simulation time, unscaled by time scaling.
            </param>
            <param name="realDeltaTime">Time delta since the last update in seconds of real time.</param>
            <returns>Connection state</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.PostUpdate">
            <summary>
            Called every frame after scripts are updated. Sends an update to the server if it is time to send the next
            update.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.CallEntityRPC(KS.Reactor.Client.ksBaseEntity,System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Calls an entity function on the server. Does nothing if not connected to the server.</summary>
            <param name="entity">Entity to call rpc on.</param>
            <param name="rpcId">Id of function to call on server.</param>
            <param name="arguments">arguments to send to server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.AddOwnedEntity(KS.Reactor.Client.ksBaseEntity)">
            <summary>Adds an entity to the list of owned entities.</summary>
            <param name="entity">entity to add.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.RemoveOwnedEntity(KS.Reactor.Client.ksBaseEntity)">
            <summary>Removes an entity from the list of owned entities.</summary>
            <param name="entity">entity to remove.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.PushTime(System.UInt32,System.Double,System.Single,System.Single,System.UInt64)">
            <summary>Pushes a time update.</summary>
            <param name="playerId">Id of player this time update is for. Zero if it's for the server.</param>
            <param name="serverTime">Total amount of simulated server time in seconds.</param>
            <param name="serverUnscaledDeltaTime">Amount of simulated server time between sync frames in seconds.</param>
            <param name="serverTimeScale">Server time scale</param>
            <param name="frame">Server frame number.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.AcknowledgeInput(System.Int32)">
            <summary>Decrements the pending input acknowlegement counter.</summary>
            <param name="numAcknowlegements">amount to decrement by.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.FindOrCreatePlayer(System.UInt32,KS.Reactor.Client.ksBasePlayer@)">
            <summary>Find an existing <see cref="T:KS.Reactor.Client.ksBasePlayer"/> or create a new one</summary>
            <param name="playerId">player id</param>
            <param name="player">The player</param>
            <returns>true if a new player was created</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ActivatePlayer(System.UInt32)">
            <summary>Move new player to the active player list and load scripts.</summary>
            <param name="playerId">player id</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.InvokePlayerJoin(System.UInt32)">
            <summary>Invokes the on player join event, and initializes scripts on the player.</summary>
            <param name="playerId">player id of player to invoke event for.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ActivateEntity(KS.Reactor.Client.EntityState,System.UInt32,System.Boolean,KS.Reactor.ksSpawnParams)">
            <summary>
            Add the new entity state to the entity state list, spawn an entity and fire an entity spawn event.
            </summary>
            <param name="entityState">entity state</param>
            <param name="assetId">Identifies the entity prefab</param>
            <param name="delayInitialize">
            If true, will delay initialize entity scripts and invoking the spawn event until after processing a server
            frame.
            </param>
            <param name="spawnParams">
            If the entity was spawned by the local player, this is the spawn parameters object used to spawn the
            entity, otherwise it is null.
            </param>
            <returns>true if the <paramref name="entityState"/> was succesfully activated.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ConfirmPlayerSpawnedEntity(KS.Reactor.Client.EntityState,KS.Reactor.ksEntityId)">
            <summary>Updates the entity's id and queues a confirm spawn event.</summary>
            <param name="entityState">
            Entity state spawned by the local player whose spawn was confirmed by the server.
            </param>
            <param name="entityId">The new id for the entity from the server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DestroyPlayer(System.UInt32)">
            <summary>Remove a player from the room and fire a player disconnect event.</summary>
            <param name="playerId">player id</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DestroyEntity(KS.Reactor.Client.EntityState,KS.Reactor.Client.ksDestroyReason)">
            <summary>Remove an entity from the room and fire a entity destroy event.</summary>
            <param name="entityState">Entity state to destroy.</param>
            <param name="reason">The reason the entity was destroyed.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.AddPredictingEntityState(KS.Reactor.Client.EntityState)">
            <summary>
            Adds an entity state to the predicting entity state list if it is not already in the list.
            </summary>
            <param name="entityState">Entity state to add.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.RemovePredictingEntityState(KS.Reactor.Client.EntityState)">
            <summary>Removes an entity state from the predicting entity state list.</summary>
            <param name="entityState">Entity state to remove.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.IncrementPlayerTimeObjectCount(System.UInt32)">
            <summary>Increments the object count for a player time.</summary>
            <param name="playerId">Id of the player time to increment the object count for.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DecrementPlayerTimeObjectCount(System.UInt32)">
            <summary>
            Decrements the object count for a player time. Removes the player time if the count reaches zero.
            </summary>
            <param name="playerId">Id of the player time to decrement the object count for.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ExecuteRoomRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Execute an RPC on the room</summary>
            <param name="rpcId">RPC id</param>
            <param name="rpcArgs">RPC arguments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ExecuteEntityRPC(KS.Reactor.ksEntityId,System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Execute an RPC on an entity.</summary>
            <param name="entityId"></param>
            <param name="rpcId">RPC id</param>
            <param name="rpcCArgs">RPC arguments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.AddSmoothedPropertySync(KS.Reactor.Client.PropertySync)">
            <summary>
            Adds a property sync to the list of property syncs with smoothed properties if it is not already in the
            list.
            </summary>
            <param name="propertySync"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.RemoveSmoothedPropertySync(KS.Reactor.Client.PropertySync)">
            <summary>Removes a property sync from the list of property syncs with smoothed properties.</summary>
            <param name="propertySync"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.RegisterConnectionFactory(KS.Reactor.ksConnectionProtocols,KS.Reactor.Client.ksConnection.Factory)">
            <summary>
            Add a connection factory for a protocol.
            If a null factory is provided, then any existing factory with that protocol is removed.
            </summary>
            <param name="protocol">connection protocol</param>
            <param name="connectionFactory">connection factory</param>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsIdle">
            <summary>Is the connection idle?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IdleTime">
            <summary>Amount of time the player has been idle. Negative if the player is not idle.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.RemoveSyncGroups(System.Collections.Generic.HashSet{System.UInt32})">
            <summary>Clean up room dependencies on a set of sync groups.</summary>
            <param name="syncGroups">sync groups</param>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Protocol">
            <summary>Get / Set the connection protocol used for new connections.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Invoke managed RPCs on all room scripts.</summary>
            <param name="rpcId">RPC ID</param>
            <param name="rpcArgs">RPC arguments</param>
            <returns>True if the method invoked any RPC handler</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2">
            <summary>
            Templated base class for rooms. Rooms are used to connect to server rooms.
            The room maintains simulation state that is regularly synced with the server.
            </summary>
            <typeparam name="Player">Implementation of <see cref="T:KS.Reactor.Client.ksBasePlayer"/></typeparam>
            <typeparam name="Entity">Implementation of <see cref="T:KS.Reactor.Client.ksBaseEntity"/></typeparam>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.PlayerJoinHandler">
            <summary>Player join event handler.</summary>
            <param name="player">player who joined the room.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.PlayerLeaveHandler">
            <summary>Player leave event handler.</summary>
            <param name="player">player who left the room.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.SpawnEntityHandler">
            <summary>Spawn entity event handler.</summary>
            <param name="entity">entity that was spawned.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.DestroyEntityHandler">
            <summary>Destroy entity event handler.</summary>
            <param name="entity">entity that was destroyed.</param>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnConnect">
            <summary>Invoked when the room is connected</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnDisconnect">
            <summary>Invoked when the room is disconnected</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnPlayerJoin">
            <summary>Invoked when a player joins the room.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnPlayerLeave">
            <summary>Invoked when a (non-local) player leaves the room.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnSpawnEntity">
            <summary>Invoked when an entity is spawned.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnDestroyEntity">
            <summary>Invoked when an entity is destroyed.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnInputUpdate">
            <summary>
            Invoked on every input update before inputs are sent or calling 
            <see cref="M:KS.Reactor.Client.ksIPredictor.InputUpdate(KS.Reactor.ksInput)"/> on the predictors of controlled entities.
            </summary>
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.PreSendFrame">
            <summary>
            Invoked before sending a frame of client data to the server. Use this to set properties you want sent to the
            server on locally-owned entities with the <see cref="F:KS.Reactor.ksOwnerPermissions.PROPERTIES"/> permission.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.OnPropertyChange">
            <summary>
            Invoked when a room property changes. Indexed by property id. Other properties are not guaranteed to be
            updated when this fires.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.OnRPC">
            <summary>Invoked when the server calls an RPC on the room. Indexed by RPC id.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Coroutines">
            <summary>Coroutines</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Info">
            <summary>Room Info</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Time">
            <summary>Server time and local frame delta.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Properties">
            <summary>Properties</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Predictor">
            <summary>Predictor for room properties.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsConnecting">
            <summary>Are we in the process of establishing a connection with the server?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsConnected">
            <summary>Are we connected to the server?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsDisconnecting">
            <summary>Are we disconnecting from the server?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.SuppressCannotCallRPCWarning">
            <summary>Should we suppress "Cannot call RPC" warnings when disconnected or disconnecting?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.LocalPlayer">
            <summary>
            The local player. This will be null until we've received an update from the server. It will also be null if
            the local player is not visible.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Players">
            <summary>List of players connected to the room.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetPlayer(System.UInt32)">
            <summary>Get a player by id.</summary>
            <param name="id">Player id</param>
            <returns>Player with the given id, or null if none was found.</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Entities">
            <summary>List of entities in the room.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.PermanentEntities">
            <summary>List of permanent entities.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.DynamicEntities">
            <summary>List of dynamic (non-permanent) entities.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.OwnedEntities">
            <summary>List of entities owned by the local player.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.LocalPlayerId">
            <summary>The local player id.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.InputAcknowledged">
            <summary>Has the server acknowledged receiving our first input?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.SendRate">
            <summary>
            How many updates we send to the server in one second. Must be between
            <see cref="F:KS.Reactor.Client.ksBaseRoom.MIN_SEND_RATE"/> and <see cref="F:KS.Reactor.Client.ksBaseRoom.MAX_SEND_RATE"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.InputInterval">
            <summary>
            The interval in seconds at which input updates are generated and sent to the server. An input update is a
            collection of button, axes, and value states represented by <see cref="T:KS.Reactor.ksInput"/>. If set to zero, sends
            one input update for every client frame. If less than zero, input updates are not sent automatically and
            must be sent by calling <see cref="M:KS.Reactor.Client.ksBaseRoom`2.SendInput(System.Boolean,System.Single)"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.SendUnchangedInput">
            <summary>
            If true, sends all input updates to the server. If false, only sends input updates to the server when the
            input changed since the last input update. Unless you are using a custom
            <see cref="!:Server.ksIInputProcessor"/> that requires every input update to be sent, there is no reason to
            set this to true.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.MultiButtonStateEnabled">
            <summary>
            If true and multiple input updates are combined into one input update, a button can be both pressed and
            released in the same update if it's up/down state changed multiple times in the same update. If false, the
            up/down state of a button can only change once in one input update.
            
            If <see cref="P:KS.Reactor.Client.ksBaseRoom`2.InputInterval"/> is zero so one input update is generated for every client frame, this has no
            effect.
            
            Eg. Three client frames are combined into one input update. The button is up on the first frame, down on the
            second, and up again on the third. If <see cref="P:KS.Reactor.Client.ksBaseRoom`2.MultiButtonStateEnabled"/> is true, this produces one
            input update where <see cref="M:KS.Reactor.ksInput.IsDown(System.UInt32)"/> returns false, and
            <see cref="M:KS.Reactor.ksInput.IsPressed(System.UInt32)"/> and <see cref="M:KS.Reactor.ksInput.IsReleased(System.UInt32)"/> return true. If
            <see cref="P:KS.Reactor.Client.ksBaseRoom`2.MultiButtonStateEnabled"/> is false, this produces one input update where
            <see cref="M:KS.Reactor.ksInput.IsDown(System.UInt32)"/> and <see cref="M:KS.Reactor.ksInput.IsPressed(System.UInt32)"/> return true and
            <see cref="M:KS.Reactor.ksInput.IsReleased(System.UInt32)"/> returns false. If the button up/down state does not change again
            during the next input update, <see cref="M:KS.Reactor.ksInput.IsDown(System.UInt32)"/> will return false and
            <see cref="M:KS.Reactor.ksInput.IsReleased(System.UInt32)"/> will return true on the next input update.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.PropertySync">
            <summary>Property sync</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.InputManager">
            <summary>Input manager</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.InputRegistrar">
            <summary>Input registrar</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Input">
            <summary>Input</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.PlayerTimeAdjusterFactory">
            <summary>Factory for creating player time adjusters.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.DecodeFrameSections">
            <summary>
            Is frame section decoding enabled? If false, entities/players/properties/rpcs will not be decoded. Throws an
            exception if set on a room that is connected or connecting.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.RPCLatency">
            <summary>Round trip latency in milliseconds measured with RPC calls. -1 if undetermined.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Latency">
            <summary>Round trip latency measured in milliseconds with the connection protocol. -1 if undetermined.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.ReadProgress">
            <summary>Get the size and progress of the current connection read operation.</summary>
            <returns></returns>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.WriteProgress">
            <summary>Get the size and progress of the current connection write operation.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.#ctor(KS.Reactor.ksRoomInfo)">
            <summary>Constructor</summary>
            <param name="roomInfo">Determines where we connect.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetEntity(KS.Reactor.ksEntityId)">
            <summary>Gets the entity in this room with the given id.</summary>
            <param name="entityId">Id of entity to get.</param>
            <returns>Entity with the given id, or null if no entity with that id was found.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetEntityState(KS.Reactor.ksEntityId)">
            <summary>Gets an entity state by id.</summary>
            <param name="entityId">Id of entity to get entity state for.</param>
            <returns>Entity state, or null if none was found.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetTime(System.UInt32)">
            <summary>
            Gets a player's time object. Each player who owns entities with the transform permission has time a time
            object that tracks their timing data which can be used to smooth motion for the entities they control.
            </summary>
            <param name="playerId">Id of player to get the time object for. If zero, gets <see cref="P:KS.Reactor.Client.ksBaseRoom`2.Time"/>.</param>
            <returns>
            The time object for the player, or <see cref="P:KS.Reactor.Client.ksBaseRoom`2.Time"/> if <paramref name="playerId"/> was zero, or null if
            the player has no owned entities with the transform permission.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SendInput(System.Boolean,System.Single)">
            <summary>
            Generates an input update to send to the server, and calls <see cref="M:KS.Reactor.Client.ksIPredictor.InputUpdate(KS.Reactor.ksInput)"/>
            on predictors for entities with player controllers.
            </summary>
            <param name="forceUpdate">
            if false, will only send a new input update to server if there were input changes
            since the last input update.
            </param>
            <param name="deltaTime">
            the time step to use when calling <see cref="M:KS.Reactor.Client.ksIPredictor.InputUpdate(KS.Reactor.ksInput)"/> on predictors. If less
            than zero, the time deltas are unchanged. Otherwise, they are set to the following:
            <see cref="P:KS.Reactor.ksTime.UnscaledDelta"/> = deltaTime
            <see cref="P:KS.Reactor.Client.ksClientTime.AdjustedUnscaledDelta"/> *= (deltaTime / <see cref="P:KS.Reactor.ksTime.UnscaledDelta"/>)
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UpdateInputPredictors(System.Single)">
            <summary>
            Calls <see cref="M:KS.Reactor.Client.ksIPredictor.InputUpdate(KS.Reactor.ksInput)"/> on predictors for entities with player controllers.
            </summary>
            <param name="deltaTime">
            the time step to use when calling <see cref="M:KS.Reactor.Client.ksIPredictor.InputUpdate(KS.Reactor.ksInput)"/> on predictors. If less
            than zero, the time deltas are unchanged. Otherwise, they are set to the following:
            <see cref="P:KS.Reactor.ksTime.UnscaledDelta"/> = deltaTime
            <see cref="P:KS.Reactor.Client.ksClientTime.AdjustedUnscaledDelta"/> *= (deltaTime / <see cref="P:KS.Reactor.ksTime.UnscaledDelta"/>)
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UpdateInput(System.Boolean)">
            <summary>Updates inputs by querying the <see cref="P:KS.Reactor.Client.ksBaseRoom`2.InputManager"/> for input state.</summary>
            <param name="buttonsOnly">If true, only updates button state.</param>
            <returns>True if any input state changed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.EncodeOwnedEntityUpdates">
            <summary>Generates updates for owned entities to send to the server.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CleanUp">
            <summary>
            Destroys all entities and players in the room. Call this after disconnecting. If called
            while connected, does nothing.
            </summary>
            <returns>Returns false if the room was in a state which prevented cleanup.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.Equals(KS.Reactor.Client.ksBaseRoom)" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CreatePlayer(System.UInt32)">
            <summary>Creates a player.</summary>
            <param name="id">id of player.</param>
            <returns>Player</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CreateEntity">
            <summary>Creates an entity.</summary>
            <returns>Entity</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ConnectionStarted">
            <summary>
            Called when a connection attempt starts.
            When this method returns false, the connection process will stop and the connect callback
            handler will be invoked with a ROOM_INITIALIZE_ERROR result.
            </summary>
            <returns>Returns true if room initialiation completed successfully.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Connected">
            <summary>Called when a connection completes successfully.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Disconnected">
            <summary>Called when the room disconnects.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Initialized">
            <summary>Called when after room scripts and entities are initialized after the first sync.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.LoadPermanentEntities(System.Collections.Generic.List{`1})">
            <summary>
            Loads permanent entities from the scene. Not implemented. When constructing permanent entities your
            implementation must call <see cref="!:ksBaseEntity.Initialize(uint, uint, ksTransformState, ksBaseRoom)"/>.
            </summary>
            <param name="entities">list to load permanent entities into.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.LoadPlayerScripts(`0)">
            <summary>Loads and attaches player scripts to a player.</summary>
            <param name="player">player to attach scripts to.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.InitializeScripts">
            <summary>Initializes room scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UpdateScripts">
            <summary>Updates scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Connect(KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[])">
            <summary>Connects to the server.</summary>
            <param name="session">player session</param>
            <param name="authArgs">authentication arguments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Disconnect(System.Boolean)">
            <summary>Disconnects from the server.</summary>
            <param name="immediate">if false, waits for pending writes before disconnecting.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SocketErrorToConnectStatus(System.Net.Sockets.SocketError)">
            <summary>Convert a socket error to room connect error.</summary>
            <param name="error"></param>
            <returns>Connect error</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleConnect(KS.Reactor.Client.ksConnection,System.Net.Sockets.SocketError,System.Object)">
            <summary>Handle a connection completed event.</summary>
            <param name="connection">connection</param>
            <param name="error">
            connection result (If the connection was successful this value will be <see cref="F:System.Net.Sockets.SocketError.Success"/>)
            </param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleDisconnect(KS.Reactor.Client.ksConnection,System.Net.Sockets.SocketError)">
            <summary>Handle a connection disconnect event.</summary>
            <param name="connection">connection</param>
            <param name="error">connection result</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SentPacket(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            <summary>Release the sent packet buffer.</summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="buffer">buffer that was written to the connection.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveHandshake(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            <summary>
            Handle a handshake packet.
            Decodes a the handshake packet and writes a model validation packet to the connection.
            </summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="buffer">buffer containing the packet header and body</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveValidateModel(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            <summary>
            Handle a model validation packet.
            Decodes the validate model packet and writes an authentication packet to the connection.
            </summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="buffer">buffer containing the packet header and body</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveAuthentication(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            <summary>
            Handle an authentication packet.
            Decodes the authentication packet and updates the connection state.
            </summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="buffer">buffer containing the packet header and body</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveFrame(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            <summary>Handle a frame packet.</summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="buffer">buffer containing the packet header and body</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveIdle(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            <summary>Handle an idle packet.</summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="buffer">buffer containing the packet header and body</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceivePong(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            <summary>
            Handles the reception of a pong packet.
            Decodes the packet and updates the connection latency.
            </summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="buffer">buffer containing the packet header and body</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SetConnectEvent(KS.Reactor.Client.ksBaseRoom.ConnectStatus,System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Creates a new connect event if one does not already exist.</summary>
            <param name="status">Connection error state</param>
            <param name="customStatusCode">Custom status code defined by the game developer</param>
            <param name="data">Response data from custom authenticate handlers</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SetDisconnectEvent(KS.Reactor.Client.ksBaseRoom.ConnectStatus)">
            <summary>Creates a new disconnect event if one does not already exist.</summary>
            <param name="status">Disconnection error state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleConnectionEvents">
            <summary>Calls the connect handler if the connection event is set.</summary>
            <returns>Connection state</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DiagnoseConnectionFailure">
            <summary>Diagnose connection failure to the server.</summary>
            <returns>error message</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.InitializePropertyPredictor">
            <summary>Initializes the room's property predictor.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.InitializePermanentEntities">
            <summary>Initializes permanent entities.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Update(System.Single,System.Single)">
            <summary>Updates the room. Syncs properties from the server and updates scripts.</summary>
            <param name="unscaledDeltaTime">
            Time delta since the last update in seconds of simulation time, unscaled by time scaling.
            </param>
            <param name="realDeltaTime">Time delta since last update in seconds of real time.</param>
            <returns>Connection state</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.PostUpdate">
            <summary>
            Called every frame after scripts are updated. Sends an update to the server if it is time to send the next
            update.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.QueueUpdate(KS.Reactor.Secret.RoomUpdate)">
            <summary>Queues a room update.</summary>
            <param name="update">Update to queue.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ProcessServerFrame">
            <summary>Processes an update from the server.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.InvokeOnSpawnEntity(`1)">
            <summary>Invokes the <see cref="E:KS.Reactor.Client.ksBaseRoom`2.OnSpawnEntity"/> event.</summary>
            <param name="entity">Entity that spawned.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AcknowledgeInput(System.Int32)">
            <summary>Decrements the pending input acknowlegement counter.</summary>
            <param name="numAcknowlegements">amount to decrement by.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CallSpawnRPC(KS.Reactor.ksSpawnParams,KS.Reactor.ksMultiType[])">
            <summary>
            Spawns an entity on the client and sends a request to the server to spawn the entity. The entity will have
            a temporary spawn id until the server validates the spawn. If the server denies the spawn, the entity will
            be destroyed.
            </summary>
            <param name="spawnParams">Spawn parameters. Must have a non-zero asset id.</param>
            <param name="args">
            Additional arguments to send to the server. These will be available in the server player spawn entity event.
            </param>
            <returns>Spawned entity</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CallRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Calls a function on the server. Does nothing if not connected to the server.</summary>
            <param name="rpcId">rpcId of function to call on server.</param>
            <param name="arguments">arguments to send to server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CallEntityRPC(KS.Reactor.Client.ksBaseEntity,System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Calls an entity function on the server. Does nothing if not connected to the server.</summary>
            <param name="entity">Entity to call RPC on.</param>
            <param name="arguments">arguments to send to server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.PushTime(System.UInt32,System.Double,System.Single,System.Single,System.UInt64)">
            <summary>Pushes a time update.</summary>
            <param name="playerId">Id of player this time update is for. Zero if it's for the server.</param>
            <param name="serverTime">Total amount of simulated server time in seconds.</param>
            <param name="serverUnscaledDeltaTime">Amount of simulated server time between sync frames in seconds.</param>
            <param name="serverTimeScale">Server time scale</param>
            <param name="frame">Server frame number.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CallBatchRPC(System.Collections.Generic.IList{`1},System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Calls an entity function on the server. Does nothing if not connected to the server.</summary>
            <param name="entities">entities to call rpc on.</param>
            <param name="rpcId">rpcId of function to call on server.</param>
            <param name="arguments">arguments to send to server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetOrCreateTimeObject(System.UInt32)">
            <summary>Gets a time object, or creates one if none is found.</summary>
            <param name="playerId">Id of player to get time object for. Zero to get the server time object.</param>
            <returns>The time object.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AddPlayerTimeObject(KS.Reactor.Client.ksBaseRoom.PlayerTime)">
            <summary>Adds a player time to the player time map and player time list.</summary>
            <param name="time">Player time to add.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemovePlayerTimeObject(KS.Reactor.Client.ksBaseRoom.PlayerTime)">
            <summary>Removes a player time from the player time map and player time list.</summary>
            <param name="time">Player time to remove.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.CanCallRPC" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SyncTime(System.Single,System.Single)">
            <summary>Syncs time with the server.</summary>
            <param name="unscaledDeltaTime">
            Time delta since the last update in seconds of simulation time, unscaled by time scaling.
            </param>
            <param name="realDeltaTime">Time delta since last update in seconds of real time.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AddOwnedEntity(KS.Reactor.Client.ksBaseEntity)">
            <summary>Adds an entity to the list of controlled entities.</summary>
            <param name="entity">entity to add.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemoveOwnedEntity(KS.Reactor.Client.ksBaseEntity)">
            <summary>Removes an entity from the list of controlled entities.</summary>
            <param name="entity">entity to remove.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.FindOrCreatePlayer(System.UInt32,KS.Reactor.Client.ksBasePlayer@)">
            <summary>Find an existing ksBasePlayer or create a new one</summary>
            <param name="playerId">player id</param>
            <param name="player">player</param>
            <returns>true if a new player was created</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ActivatePlayer(System.UInt32)">
            <summary>Moves a new player to the active player list and initializes properties and scripts.</summary>
            <param name="playerId">player id</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.InvokePlayerJoin(System.UInt32)">
            <summary>Invokes the on player join event, and initializes scripts on the player.</summary>
            <param name="playerId">player id of player to invoke event for.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ActivateEntity(KS.Reactor.Client.EntityState,System.UInt32,System.Boolean,KS.Reactor.ksSpawnParams)">
            <summary>
            Add the new entity state to the entity state list, spawn an entity and fire an entity spawn event.
            </summary>
            <param name="entityState">entity state</param>
            <param name="assetId">Identifies the entity prefab</param>
            <param name="delayInitialize">
            If true, will delay initialize entity scripts and invoking the spawn event until after processing a server
            frame.
            </param>
            <param name="spawnParams">
            If the entity was spawned by the local player, this is the spawn parameters object used to spawn the
            entity, otherwise it is null.
            </param>
            <returns>true if the <paramref name="entityState"/> was succesfully activated.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ConfirmPlayerSpawnedEntity(KS.Reactor.Client.EntityState,KS.Reactor.ksEntityId)">
            <summary>Updates the entity's id and queues a confirm spawn event.</summary>
            <param name="entityState">
            Entity state spawned by the local player whose spawn was confirmed by the server.
            </param>
            <param name="entityId">The new id for the entity from the server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DestroyPlayer(System.UInt32)">
            <summary>Remove a player from the room and fire a player leave event.</summary>
            <param name="playerId">player id</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DestroyEntity(KS.Reactor.Client.EntityState,KS.Reactor.Client.ksDestroyReason)">
            <summary>Remove an entity from the room and fire a entity destroy event.</summary>
            <param name="entityState">Entity state to destroy.</param>
            <param name="reason">The reason the entity was destroyed.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AddPredictingEntityState(KS.Reactor.Client.EntityState)">
            <summary>
            Adds an entity state to the predicting entity state list if it is not already in the list.
            </summary>
            <param name="entityState">Entity state to add.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemovePredictingEntityState(KS.Reactor.Client.EntityState)">
            <summary>Removes an entity state from the predicting entity state list.</summary>
            <param name="entityState">Entity state to remove.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.IncrementPlayerTimeObjectCount(System.UInt32)">
            <summary>Increments the object count for a player time.</summary>
            <param name="playerId">Id of the player time to increment the object count for.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DecrementPlayerTimeObjectCount(System.UInt32)">
            <summary>
            Decrements the object count for a player time. Removes the player time if the count reaches zero.
            </summary>
            <param name="playerId">Id of the player time to decrement the object count for.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ExecuteRoomRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Execute an RPC on the room.</summary>
            <param name="rpcId">RPC id</param>
            <param name="rpcArgs">RPC arguments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ExecuteEntityRPC(KS.Reactor.ksEntityId,System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Execute an RPC on an entity.</summary>
            <param name="entityId"></param>
            <param name="rpcId">RPC id</param>
            <param name="rpcArgs">RPC arguments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AddSmoothedPropertySync(KS.Reactor.Client.PropertySync)">
            <summary>
            Adds a property sync to the list of property syncs with smoothed properties if it is not already in the
            list.
            </summary>
            <param name="propertySync"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemoveSmoothedPropertySync(KS.Reactor.Client.PropertySync)">
            <summary>Removes a property sync from the list of property syncs with smoothed properties.</summary>
            <param name="propertySync"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RegisterRPC(System.UInt32,KS.Reactor.Client.ksBaseRoom.RPCHandler)">
            <summary>Register an RPC</summary>
            <param name="rpcId">RPC Id</param>
            <param name="rpcHandler">RPC handler</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UnregisterRPC(System.UInt32,KS.Reactor.Client.ksBaseRoom.RPCHandler)">
            <summary>Unregister an RPC</summary>
            <param name="rpcId">RPC Id</param>
            <param name="rpcHandler">RPC handler</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SendPing(System.Single)">
            <summary>Send ping requests to the server.</summary>
            <param name="delta">Time between update frames.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UpdateLatency(System.Byte,System.Int64,System.Int64[],System.Int32@,System.Int32@)">
            <summary>Update latency with new netowrk and RPC ping times.</summary>
            <param name="type">Ping type (0 = network, 1 = RPC)</param>
            <param name="time">ping send time</param>
            <param name="history">ping history</param>
            <param name="index">current ping index in the history array</param>
            <param name="latency">latency value to update</param>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetPropertyServerValue(System.UInt32)">
            <summary>
            Gets property server value. If a property id is not in the map,
            a <see cref="T:KS.Reactor.ksMultiType"/> of type <see cref="F:KS.Reactor.ksMultiType.Types.NULL"/> is returned.
            </summary>
            <param name="propertyId"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleIdle">
            <summary>
            When becoming idle we destroy all entity states to avoid prediction extrapolation and because
            the first frame after disabling idle will be a full sync frame which will create the objects.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsIdle">
            <summary>Is the connection idle?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IdleTime">
            <summary>Amount of time the player has been idle. Negative if the player is not idle.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemoveSyncGroups(System.Collections.Generic.HashSet{System.UInt32})">
            <summary>Clean up room dependencies on a set of sync groups.</summary>
            <param name="syncGroups">sync groups</param>
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Protocol">
            <summary>Get/Set the network protocol to use for connections.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ToString">
            <summary>Returns a string containing the room id, room type, and scene name.</summary>
            <returns>containing the room id, room type, and scene name.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksClientInputPredictor">
            <summary>Predicts movement and properties using only the player controller; server data is ignored.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientInputPredictor.RequiresController">
            <summary>Always true; the client input predictor requires a player controller.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)">
            <summary>Initializes the predictor.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <param name="player">
            Player the predictor is smoothing properties for. Null if the predictor is not smoothing player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.ParentChange(KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBaseEntity)">
            <summary>
            Invoked when the Entity parent changes. This method should correct predicted values by converting the positions back to world positions
            for the removal of the old parent and then to the local position for the new parent.
            </summary>
            <param name="oldParent">Parent entity being removed.</param>
            <param name="newParent">Parent entity being added.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.Enabled">
            <summary>
            Called when the predictor is enabled. May be called multiple times. Called after 
            <see cref="M:KS.Reactor.Client.ksClientInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)"/>. When an entity switches between the
            <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called
            on the one that was switched to.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.Disabled">
            <summary>
            Called when the predictor is disabled. May be called multiple times. Called before <see cref="M:KS.Reactor.Client.ksClientInputPredictor.Detached"/>.
            When an entity switches between the <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and 
            <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called on the one that was switched off.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksClientInputPredictor.Detached" -->
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.IsPredictedProperty(System.UInt32)">
            <summary>
            Does the predictor predict the property value with the given <paramref name="propertyId"/>?
            </summary>
            <param name="propertyId">Property id</param>
            <returns>True if the predictor predicts the property value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.ServerUpdate(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">Server transform data.</param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleport">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.ClientUpdate(KS.Reactor.ksTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">Client transform to update with new values.</param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="T:KS.Reactor.Client.ksClientTime">
            <summary>
            Holds time data that is available on the client. In addition to the client time object for the room, each player
            that owns entities with the transform permission has a client time object that can be accessed using 
            <see cref="M:KS.Reactor.Client.ksBaseRoom.GetTime(System.UInt32)"/> and holds timing data that can be used to smooth motion for entities they
            control. For player time, <see cref="P:KS.Reactor.ksTime.Frame"/> is the last received server frame number that contained
            owned-entity updates from that player, <see cref="P:KS.Reactor.ksTime.TimeScale"/> is always one, 
            <see cref="P:KS.Reactor.Client.ksClientTime.ServerUnscaledDelta"/> is the amount of time between passed on the remote client between their last
            two owned-entity updates, and <see cref="P:KS.Reactor.Client.ksClientTime.AdjustedUnscaledDelta"/> is a different value calculated by the
            <see cref="P:KS.Reactor.Client.ksClientTime.Adjuster"/> for that player time.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksClientTime.m_zero">
            <summary>Time with zero for all values.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.PlayerId">
            <summary>The id of the player the time data is for. Zero if this holds the server time data.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.AdjustedDelta">
            <summary>
            Local game time in seconds since the last update, adjusted by <see cref="P:KS.Reactor.Client.ksClientTime.Adjuster"/> to try stay in sync
            with the server, with time scaling applied.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.AdjustedUnscaledDelta">
            <summary>
            Local game time in seconds since the last update, adjusted by <see cref="P:KS.Reactor.Client.ksClientTime.Adjuster"/> to try stay in sync
            with the server, without time scaling applied.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.RealDelta">
            <summary>
            Real time in seconds since the last update. For games that do not used a fixed-time step, this will be the
            same as <see cref="P:KS.Reactor.ksTime.UnscaledDelta"/>. In Unity this is the same as <see cref="P:KS.Reactor.ksTime.UnscaledDelta"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.ServerTime">
            <summary>Simulated server time in seconds.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.ServerDelta">
            <summary>
            Amount of time simulated on the server since the previous server frame. If this is player time data, this
            is the amount of time passed for the remote client between their last two owned-entity updates.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.ServerUnscaledDelta">
            <summary>
            Amount of unscaled time simulated on the server since the previous server frame. If this is player time
            data, this is the amount of time passed for the remote client between their last two owned-entity updates.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.Adjuster">
            <summary>
            The time adjuster for calculating <see cref="P:KS.Reactor.Client.ksClientTime.AdjustedUnscaledDelta"/> to try stay in sync with the server.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksClientTime.#ctor(System.UInt32)">
            <summary>Constructor</summary>
            <param name="playerId">Id of the player this time object is for. Zero if it holds server time data.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksClientTime.Reset">
            <summary>Resets all time values to their defaults.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksConnection">
            <summary>Base class for network connections.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.ConnectOperation">
            <summary>Track connect operations</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.ConnectOperation.#ctor(KS.Reactor.Client.ksConnection.ConnectHandler,System.Object)">
            <summary>Constructor</summary>
            <param name="callback">Callback to invoke when the connection attempt succeeds or fails</param>
            <param name="asyncState">Aysnc state object</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.IOOperation">
            <summary>Track read/write operations</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.IOOperation.#ctor(System.Net.Sockets.SocketAsyncOperation,KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            <summary>Constructor.</summary>
            <param name="type">Type of socket operation</param>
            <param name="segment">Stream buffer segment to operate on</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="asyncState">Async state object</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.Factory">
            <summary>Method to generate connections.</summary>
            <returns>Connection</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.ConnectHandler">
            <summary>Handler called when connection attempts complete.</summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="error">
            connection result (If the connection was successful this value will be SocketError.Success)
            </param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.DisconnectHandler">
            <summary>Handler called when connection disconnects.</summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="error">connection result</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.IOHandler">
            <summary>Handler called when a read/write operation completes.</summary>
            <param name="connection">connection that is calling the handler</param>
            <param name="segment">buffer segment that was read from or written to</param>
            <param name="error">operation result</param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="E:KS.Reactor.Client.ksConnection.OnDisconnect">
            <summary>Called when the connection is disconnected.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.Address">
            <summary>Return the host and port as a single address string.</summary>
            <returns>Host and port string</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.ReadProgress">
            <summary>Get the progress of the current read operation.</summary>
            <returns>Read progress</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.WriteProgress">
            <summary>Get the progress of the current write operation.</summary>
            <returns>Write progress</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.IsConnected">
            <summary>Check if a connection to the server is open.</summary>
            <returns>True if connected to the server.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Connect(System.String,System.UInt16,KS.Reactor.Client.ksConnection.ConnectHandler,System.Object)">
            <summary>Establish a connection to a server.</summary>
            <param name="host">server host name</param>
            <param name="port">server port</param>
            <param name="callback">callback to invoke when the connection attempt completes</param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Disconnect(System.Boolean)">
            <summary>Disconnect from the server.</summary>
            <param name="immediate">
            If this is false, then queued write operations will complete before disconnecting.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Read(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            <summary>Read data from the connection into a stream buffer segment.</summary>
            <param name="segment">segment of a larger stream buffer</param>
            <param name="callback">callback to invoke when the read operation completes</param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Write(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            <summary>Read data from the connection into a stream buffer segment.</summary>
            <param name="segment">segment of a larger stream buffer</param>
            <param name="callback">callback to invoke when the write operation completes</param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.TryResolveHost(System.String,System.Net.IPAddress@)">
            <summary>
            Try to resolve a host string to an IP Address. This method first checks if the 
            string is a valid IP address and if that fails it will attempt to resolve the
            address using DNS services.
            </summary>
            <param name="host">Host or IP string</param>
            <param name="ipAddress">IP Address</param>
            <returns>True if a valid IP address was resolved.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor">
            <summary>
            Predicts movement and properties based on user input using a player controller. Accelerations are slower than
            the server so the client and server will converge. Controller updates are used to predict a future server
            position, and the client render position interpolates towards the predicted server position. New server frames
            will make corrections to the future predicted server position, and may trigger a rewind and replay of
            controller inputs to get a new predicted server position.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.ResetPropertyCallback">
            <summary>
            Property reset callback, called when a property is reset to the server state before replaying inputs
            through the player controller.
            </summary>
            <param name="value">Server property value.</param>
            <param name="changeRate">Server property change rate per second.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.MoveChecker">
            <summary>
            Delegate for checking for collisions and repositioning the entity when moving between two points.
            </summary>
            <param name="entity">Entity to move.</param>
            <param name="startPosition">Entity starting position.</param>
            <param name="targetPosition">Position to move the entity to.</param>
            <param name="isRenderPosition">
            Will the result of this move be the position the entity is rendered at? This matters when the controlled
            entity is a kinematic rigid body, where sometimes the predicted server position is moved and we don't want
            to check for collisions with dynamic rigid bodies that the player will push away, and sometimes the render
            position is moved and we do want to check for those collisions to prevent the render position from
            embedding with dynamic objects.
            </param>
            <returns>Position to move the entity to.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame">
            <summary>Client input frame. Contains input and delta time.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame.Input">
            <summary>Input state for the frame.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame.UnscaledDeltaTime">
            <summary>Frame duration in seconds without time scaling applied.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame.TimeScale">
            <summary>Frame time scaling.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame.#ctor(KS.Reactor.ksInput,System.Single,System.Single)">
            <summary>Constructor</summary>
            <param name="input">Input state for the frame.</param>
            <param name="unscaledDeltaTime">Frame duration in seconds without time scaling applied.</param>
            <param name="timeScale">Frame time scale.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData">
            <summary>Configuration parameters for the converging input predictor.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.Default">
            <summary>Default configuration values. Values can be changed to change the defaults.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityToleranceCalculator">
            <summary>
            Calculates the velocity tolerance for an entity. Called when <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityTolerance"/> is negative.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.TunnelDistanceCalculator">
            <summary>
            Calculates the tunnel distance for an entity. Called when <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.TunnelDistance"/> is negative.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.ConvergeMultiplier">
            <summary>Lower values mean we try to converge more aggressively.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.MaxDeltaTime">
            <summary>
            Maximum time step for the client over a single frame. If a frame's time delta is larger than this, this
            is used as the time delta instead. The predictor behaves poorly with large time steps, and limiting the
            maximum time step can improve the behaviour when there are dips in frame rate.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.DefaultLatency">
            <summary>Latency in seconds to use before latency is determined.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.UseClientOnlyPosition">
            <summary>
            If true, converging prediction is not run on the position. Instead the player controller alone
            determines the client position. Changing this after
            <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)"/> is called does nothing.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.UseClientOnlyRotation">
            <summary>
            If true, converging prediction is not run on the rotation. Instead the player controller alone
            determines the client rotation. Changing this after
            <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)"/> is called does nothing.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.UseClientOnlyScale">
            <summary>
            If true, converging prediction is not run on the scale. Instead the player controller alone determines
            the client scale. Changing this after <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)"/>
            is called does nothing.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.SlideParams">
            <summary>Sweep and slide parameters.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.SweepAndSlideIterations">
            <summary>
            Max number of sweep-and-slide iterations for predicting collisions. One to stop after the first sweep
            without sliding.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.MaxSlideAngle">
            <summary>
            Do not allow slides that change the movement direction by more than this angle in degrees. Less than zero
            for no limit.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.MaxTotalSlideAngle">
            <summary>
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.SeparationOffset">
            <summary>Keep this much distance between other objects. Helps prevent penetrations.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.MoveCheck">
            <summary>
            Sometimes the predictor needs to move the entity between two points. Use this to test for collisions
            along the way and change the final position of the entity. By default this is set to 
            <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.MoveCheck(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Boolean)"/>. You
            should not need to change this unless you are using a custom collision detection system. Set to null to
            disable collision checks.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.CheckKinematicDynamicCollisions">
            <summary>
            If true and the controlled entity is a kinematic rigid body, <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.MoveCheck"/> will check for
            collisions with dynamic rigid bodies when updating the render position to prevent the render position
            from embedding with dynamic rigid bodies that will get pushed out of the way.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.TunnelDistance">
            <summary>
            Maximum difference between client and server positions before the client will tunnel through objects to
            get to the server position. If negative, a tunnel distance is calculated for the entity by
            <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.TunnelDistanceCalculator"/> if it is not null, otherwise one is used.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityTolerance">
            <summary>
            Maximum difference between client and server velocity before inputs are replayed. Zero for no limit. If
            negative, a velocity tolerance is calculated for the entity by
            <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityToleranceCalculator"/> if it is not null, otherwise one is used.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.PositionResetCallback">
            <summary>Called before replaying inputs with new position and velocity values.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.AngularVelocityTolerance">
            <summary>
            Maximum difference between client and server angular velocity before inputs are replayed. Less than or
            equal to zero for no limit.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.RotationResetCallback">
            <summary>Called before replaying inputs with new rotation and angular velocity values.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.PredictedProperties">
            <summary>Keys are which properties to predict, and values describe how to predict them.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.Clone">
            <summary>Creates a copy of this <see cref="T:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData"/>.</summary>
            <returns>Copy of the config.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.PropertyBehaviour">
            <summary>Describes how to predict a property.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.PropertyBehaviour.Type">
            <summary>Prediction behaviour.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:KS.Reactor.Client.ksConvergingInputPredictor.PropertyBehaviour.Tolerance" -->
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.PropertyBehaviour.OnReset">
            <summary>
            Callback to call when the property value is reset to the server value before inputs are replayed.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertyBehaviour.#ctor(KS.Reactor.Client.ksPredictionBehaviour,System.Single,KS.Reactor.Client.ksConvergingInputPredictor.ResetPropertyCallback)">
            <summary>Constructor</summary>
            <param name="type">Prediction behaviour</param>
            <param name="tolerance"><see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.PropertyBehaviour.Tolerance"/></param>
            <param name="resetCallback"></param>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Config">
            <summary>
            Configurable data for customizing the the predictor. Returns null if the predictor is using the
            <see cref="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.Default"/>. Assign this if you want to override the defaults.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.RequiresController">
            <summary>Always true; the converging input predictor requires a player controller.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.QueryObject">
            <summary>
            Query object (entity, collider, or shape) to use when testing for collisions using the default
            <see cref="T:KS.Reactor.Client.ksConvergingInputPredictor.MoveChecker"/>. Not used if the entity is a dynamic rigid body. If null, collisions will not be
            tested if the entity is not a dynamic rigid body. Note that kinematic rigid bodies will test for collisions
            with dynamic rigid bodies when moving the render position to prevent overlapping with dynamic rigid bodies
            that will get pushed out of the way, even if this is null.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.QueryFilter">
            <summary>
            Query filter to use when testing for collisions using the default <see cref="T:KS.Reactor.Client.ksConvergingInputPredictor.MoveChecker"/> with a
            non-dynamic rigid body.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.QueryFlags">
            <summary>
            Query flags to use when testing for collisions using the default <see cref="T:KS.Reactor.Client.ksConvergingInputPredictor.MoveChecker"/> with a
            non-dynamic rigid body.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ToLocal(KS.Reactor.ksVector3,System.Boolean)">
            <summary>Calculate a local position from a world position using the entity parent position.</summary>
            <param name="worldPosition">World position.</param>
            <param name="useParentServerValue">Use the parent server position when calculating the local position.</param>
            <returns>Local position.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ToWorld(KS.Reactor.ksVector3,System.Boolean)">
            <summary>Calculate a world position from a local position using the entity parent position.</summary>
            <param name="localPosition">Local position.</param>
            <param name="useParentServerValue">Use the parent server position when calculating the world position.</param>
            <returns>World position.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ToLocal(KS.Reactor.ksQuaternion,System.Boolean)">
            <summary>Calculate a local rotation from a world rotation using the entity parent rotation.</summary>
            <param name="worldRotation">World rotation.</param>
            <param name="useParentServerValue">Use the parent server rotation when calculating the local rotation.</param>
            <returns>Local rotation.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ToWorld(KS.Reactor.ksQuaternion,System.Boolean)">
            <summary>Calculate a world rotation from a local rotation using the entity parent rotation.</summary>
            <param name="localRotation">Local rotation.</param>
            <param name="useParentServerValue">Use the parent server rotation when calculating the world rotation.</param>
            <returns>World rotation.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.MoveCheck(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Boolean)">
            <summary>
            Moves an entity between two points, checking for collisions along the way and doing sweep-and-slide
            movement and depenetrating from overlapping objects at the end. Use <see cref="P:KS.Reactor.Client.ksConvergingInputPredictor.QueryObject"/>, 
            <see cref="P:KS.Reactor.Client.ksConvergingInputPredictor.QueryFilter"/>, and <see cref="P:KS.Reactor.Client.ksConvergingInputPredictor.QueryFlags"/> if you need to test for collisions with a
            non-dynamic rigid body.
            </summary>
            <param name="entity">Entity to move</param>
            <param name="startPosition">Entity starting position</param>
            <param name="targetPosition">Position to move to.</param>
            <param name="isRenderPosition">
            Will the result of this move be the position the entity is rendered at? If true and the 
            <paramref name="entity"/> is a kinematic rigid body and 
            <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.CheckKinematicDynamicCollisions"/> is true, queries will also check for collisions
            with dynamic rigid bodies that get pushed out of the way, to prevent the render position from embedding
            with dynamic objects.
            </param>
            <returns>Position to move the entity to.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)">
            <summary>Initializes the predictor.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <param name="player">
            Player the predictor is smoothing properties for. Null if the predictor is not smoothing player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ParentChange(KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBaseEntity)">
            <summary>
            Invoked when the Entity parent changes. This method should correct predicted values by converting the positions back to world positions
            for the removal of the old parent and then to the local position for the new parent.
            </summary>
            <param name="oldParent">Parent entity being removed.</param>
            <param name="newParent">Parent entity being added.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Enabled">
            <summary>
            Called when the predictor is enabled. May be zero or more times. Called after 
            <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)"/>. When an entity switches between the
            <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called
            on the one that was switched to.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Disabled">
            <summary>
            Called when the predictor is disabled. May be called zero or more times. Called before <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Detached"/>.
            When an entity switches between the <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and 
            <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called on the one that was switched off.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Detached">
            <summary>Returns inputs to their pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IsPredictedProperty(System.UInt32)">
            <summary>
            Does the predictor predict the property value with the given <paramref name="propertyId"/>?
            </summary>
            <param name="propertyId">Property id</param>
            <returns>True if the predictor predicts the property value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.CreateSmoother(KS.Reactor.Client.ksConvergingInputPredictor.PropertyBehaviour)">
            <summary>Creates a smoother for a property.</summary>
            <param name="behaviour">Behaviour for property prediction.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ServerUpdate(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">Server transform data.</param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleported">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ClientUpdate(KS.Reactor.ksTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">Client transform to update with new values.</param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PlayerControllerChanged(KS.Reactor.ksPlayerController,KS.Reactor.ksPlayerController)">
            <summary>Called when the entity's player controller changes.</summary>
            <param name="oldController">Old controller</param>
            <param name="newController">New controller</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ProcessInput(KS.Reactor.Client.ksConvergingInputPredictor.InputFrame)">
            <summary>
            Updates the controller with a frame of input. Extrapolates predictions based on the controller state.
            </summary>
            <param name="frame">Input frame</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.CompareChangeRates(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>
            Calculates property change rates from server values and compares them with client values. Does not
            calculate change rates for properties with no change tolerance.
            </summary>
            <param name="state">Server physics state.</param>
            <param name="properties">Server properties whose values changed since the last frame.</param>
            <returns>
            True if the difference in change rate between client and server values for a property exceeded
            the tolerance.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ReplayInputs(KS.Reactor.ksReadOnlyTransformState)">
            <summary>
            Resets property state to server values and replays inputs through the player controller to get a new
            predicted state.
            </summary>
            <param name="state">Server state.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IterateSmoothers">
            <summary>Iterates the smoothers.</summary>
            <returns>Iterator</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother">
            <summary>Non-templated smoother interface for smoothing a value.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.Advance">
            <summary>Removes the oldest history frame.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.Advance(System.Single)">
            <summary>Advances through the history.</summary>
            <param name="t">Time to advance between 0 and 1 where 1 is the entirety of the oldest history frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.ClearHistory">
            <summary>Clears the history.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.PredictServerValue">
            <summary>Predicts the server's current value by adding the deltas from history to the last known server value.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.Idle">
            <summary>Sets the server change rate to zero.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.CompareChangeRates">
            <summary>Gets the difference between the server and client change rates.</summary>
            <returns>Difference between server and client change rates.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.ZeroFillHistory(System.Int32)">
            <summary>Adds zero filled frames of given number to history.</summary>
            <param name="num">Number of zero filled frames that need to be added to history.</param>
            @param   int number of zero filled frames that need to be added to history.
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother">
            <summary>Interface for smoothing a <see cref="T:KS.Reactor.ksMultiType"/> property.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.Reset(KS.Reactor.ksMultiType)">
            <summary>Reset the smoother by setting all smoothing values to the same value.</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.GetServerChangeRate">
            <summary>Gets the server change rate.</summary>
            <returns>Server change rate.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.GetServerValue">
            <summary>Gets the server value.</summary>
            <returns>Server value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.SetServerValue(KS.Reactor.ksMultiType)">
            <summary>Sets the server value.</summary>
            <param name="value">Server value.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.GetPredictedServerValue">
            <returns>Predicted server value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.CalculateChangeRate(KS.Reactor.ksMultiType,System.Single)">
            <summary>Calculates the server change rate.</summary>
            <param name="nextValue">Next server value.</param>
            <param name="deltaTime">Server delta time.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.AddPrediction(KS.Reactor.ksMultiType,System.Single)">
            <summary>Sets the predicted server value and adds a prediction to the history.</summary>
            <param name="value">Predicted value.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            @param   ksMultiType value - predicted value.
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.ExtrapolatePrediction(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Updates and extrapolates the predicted server value.</summary>
            <param name="startValue">Value before the controller update.</param>
            <param name="controllerValue">Value after the controller update.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IPropertySmoother.Interpolate(KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Interpolates the client value towards a predicted future server value.</summary>
            <param name="clientValue">Client value to interpolate from.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
            <returns>New client value.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3">
            <summary>Predicts a templated type using a templated <see cref="T:KS.Reactor.Client.ISpace`2"/>.</summary>
            <typeparam name="Vector">Type of value being smoothed.</typeparam>
            <typeparam name="Delta">Delta type.</typeparam>
            <typeparam name="Space">
            Space for performing math/interpolation operations on <typeparamref name="Vector"/> and 
            <typeparamref name="Delta"/>.
            </typeparam>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame">
            <summary>Predicted frame</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame.Delta">
            <summary>Predicted delta</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame.ChangeRate">
            <summary>Predicted change rate</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame.#ctor(`1,`1)">
            <summary>Constructor</summary>
            <param name="delta">Predicted delta.</param>
            <param name="changeRate">Predicted change rate.</param>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ServerValue">
            <summary>Last known server value</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ServerChangeRate">
            <summary>Last known server change rate</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ClientChangeRate">
            <summary>Client change rate</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.PredictedServerValue">
            <summary>Predicted server value</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.VectorSpace">
            <summary>Vector space instance</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Reset(`0)">
            <summary>Reset the smoother by setting all smoothing values to the same value.</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Advance">
            <summary>Removes the oldest history frame.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Advance(System.Single)">
            <summary>Advances through the history.</summary>
            <param name="t">Time to advance between 0 and 1 where 1 is the entirety of the oldest history frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ClearHistory">
            <summary>Clears the history.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.PredictServerValue">
            <summary>Predicts the server's current value by adding the deltas from history to the last known server value.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Idle">
            <summary>Sets the server change rate to zero.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.CalculateChangeRate(`0,System.Single)">
            <summary>Calculates the server change rate.</summary>
            <param name="nextValue">Next server value.</param>
            <param name="deltaTime">Server delta time.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.CompareChangeRates">
            <summary>Gets the difference between the server and client change rates.</summary>
            <returns>Difference between server and client change rates.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.AddPrediction(`0,System.Single)">
            <summary>Sets the predicted server value and adds a prediction to the history.</summary>
            <param name="value">Predicted value.</param>
            <param name="deltaTime">Delta time in seconds.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ExtrapolatePrediction(`0,`0,System.Single,System.Single,System.Single)">
            <summary>Updates and extrapolates the predicted server value.</summary>
            <param name="startValue">Value before the controller update.</param>
            <param name="controllerValue">Value after the controller update.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Interpolate(`0,System.Single,System.Single,System.Single)">
            <summary>Interpolates the client value towards a predicted future server value.</summary>
            <param name="clientValue">Client value to interpolate from.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
            <returns>New client value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ZeroFillHistory(System.Int32)">
            <summary>Adds zero filled frames of given number to history.</summary>
            <param name="num">Number of zero filled frames that need to be added to history.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3">
            <summary>
            Extends <see cref="T:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3"/> and adds methods for accessing and passing 
            <see cref="!:Vector"/> and <see cref="!:Delta"/> data as a <see cref="T:KS.Reactor.ksMultiType"/>.
            </summary>
            <typeparam name="Vector">Type of value being smoothed.</typeparam>
            <typeparam name="Delta">Delta type.</typeparam>
            <typeparam name="Space">
            Space for performing math/interpolation operations on <typeparamref name="Vector"/> and 
            <typeparamref name="Delta"/>.
            </typeparam>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.Reset(KS.Reactor.ksMultiType)">
            <summary>Reset the smoother by setting all smoothing values to the same value.</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.GetServerChangeRate">
            <summary>Gets the server change rate.</summary>
            <returns>Server change rate.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.GetServerValue">
            <summary>Gets the server value.</summary>
            <returns>Server value</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.SetServerValue(KS.Reactor.ksMultiType)">
            <summary>Sets the server value.</summary>
            <param name="value">Server value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.GetPredictedServerValue">
            <returns>ksMultiType predicted server value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.CalculateChangeRate(KS.Reactor.ksMultiType,System.Single)">
            <summary>Calculates the server change rate.</summary>
            <param name="nextValue">Next server value.</param>
            <param name="deltaTime">Server delta time.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.AddPrediction(KS.Reactor.ksMultiType,System.Single)">
            <summary>Sets the predicted server value and adds a prediction to the history.</summary>
            <param name="value">Predicted value.</param>
            <param name="deltaTime">Delta time in seconds.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.ExtrapolatePrediction(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Updates and extrapolates the predicted server value.</summary>
            <param name="startValue">Value before the controller update.</param>
            <param name="controllerValue">Value after the controller update.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.PropertySmoother`3.Interpolate(KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Interpolates the client value towards a predicted future server value.</summary>
            <param name="clientValue">Client value to interpolate from.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
            <returns>New client value.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.KinematicFilter">
            <summary>
            Query filter that holds a reference to a <see cref="T:KS.Reactor.Client.ksConvergingInputPredictor"/> object whose filter rules
            are applied and if the result is none, it returns blocking hits with dynamic objects that pass 
            <see cref="T:KS.Reactor.ksSimulationFilter"/> rules. This is used when the query entity is a kinematic rigid body to add
            additional filtering to prevent the client render position from overlapping dynamic rigidbodies that will
            get pushed out of the way on the server.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.KinematicFilter.Filter(KS.Reactor.ksICollider,KS.Reactor.ksICollider,KS.Reactor.ksQueryResultTypes,KS.Reactor.ksBaseQueryParams)">
            <summary>
            Determines if a potential collider hit should be included in query results and whether it is a blocking or
            touching hit.
            </summary>
            <param name="queryCollider">The collider used in the query. Null for shape queries.</param>
            <param name="hitCollider">The collider being evaluated for a hit.</param>
            <param name="resultType">What kind of results the query returns</param>
            <param name="args">Query parameters</param>
            <returns>Hit type</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksDelegates">
            <summary>Collection of delegates.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksDelegates.PropertyChangeHandler">
            <summary>Property change event handler.</summary>
            <param name="oldValue">oldValue of property.</param>
            <param name="newValue">newValue of property.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksDelegates.TimeAdjusterFactory">
            <summary>Factor for creating time adjusters.</summary>
            <returns>Time adjuster</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksDestroyReason">
            <summary>Reasons for entity destruction</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksDestroyReason.SERVER_DESTROY">
            <summary>The server destroyed the entity.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksDestroyReason.SYNC_GROUP_REMOVAL">
            <summary>
            The entity stopped syncing because the player does not belong to the entity's sync group.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksDestroyReason.INVALID_PLAYER_SPAWN">
            <summary>
            The entity was spawned by the local player but the spawn request was denied by the server.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksDestroyReason.IDLE_CONNECTION">
            <summary>The connection is idle.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksDestroyReason.DISCONNECT">
            <summary>We disconnected from the room.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksFrameInfo">
            <summary>Size and download progress for a frame.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksFrameInfo.Size">
            <summary>Frame size in bytes.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksFrameInfo.AmountReceived">
            <summary>Number of bytes downloaded for the frame.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksFrameInfo.Progress">
            <summary>Amount of frame downloaded from 0 to 1.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksFrameInfo.#ctor(System.Int32,System.Int32)">
            <summary>Constructor</summary>
            <param name="size">size of frame in bytes.</param>
            <param name="amountReceived">amountReceived in bytes.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksIInputManager">
            <summary>
            Input manager interface. Rooms query the input manager for input state on input frames. Button state is queried
            every frame so button state changes aren't missed. Inputs registered with the <see cref="T:KS.Reactor.ksInputRegistrar"/> by
            <see cref="T:KS.Reactor.ksPlayerController"/>s determine which inputs are queried and sent to the server.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIInputManager.GetButton(System.UInt32)">
            <summary>Checks if a button is up or down.</summary>
            <param name="buttonId">Id of button to check.</param>
            <returns>True if the button is down.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIInputManager.GetAxis(System.UInt32)">
            <summary>Gets an axis value.</summary>
            <param name="axisId">Id of the axis value to get.</param>
            <returns>Axis value</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIInputManager.GetValue(System.UInt32)">
            <summary>Gets a value.</summary>
            <param name="valueId">Id of value to get.</param>
            <returns>Value</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksIPredictor">
            <summary>Predictor interface for smoothing/predicting entity movement and properties.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIPredictor.RequiresController">
            <summary>Does the predictor require a player controller?</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)">
            <summary>Initializes the predictor. Called when the predictor is first assigned.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <param name="player">
            Player the predictor is smoothing properties for. Null if the predictor is not smoothing player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.Enabled">
            <summary>
            Called when the predictor is enabled. May be called zero or more times. Called after 
            <see cref="M:KS.Reactor.Client.ksIPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)"/>. When an entity switches between the
            <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called
            on the one that was switched to.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.Disabled">
            <summary>
            Called when the predictor is disabled. May be called zero or more times. Called before <see cref="M:KS.Reactor.Client.ksIPredictor.Detached"/>.
            When an entity switches between the <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and 
            <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called on the one that was switched off.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.Detached">
            <summary>
            Called when the predictor is removed. Predictors that use pooling will be returned to the pool.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.IsPredictedProperty(System.UInt32)">
            <summary>
            Does the predictor predict the property value with the given <paramref name="propertyId"/>?
            </summary>
            <param name="propertyId">Property id</param>
            <returns>True if the predictor predicts the property value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.ServerUpdate(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">Server transform data. Null if not smoothing a transform.</param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleport">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.ClientUpdate(KS.Reactor.ksTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">Client transform to update with new values. Null if not smoothing a transform.</param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.ParentChange(KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBaseEntity)">
            <summary>
            Invoked when the Entity parent changes. This method should correct predicted values by converting the positions back to world positions
            for the removal of the old parent and then to the local position for the new parent.
            </summary>
            <param name="oldParent">Parent entity being removed.</param>
            <param name="newParent">Parent entity being added.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksIRoom`2">
            <summary>
            Room interface used internally for testing with mock implementations. It is incomplete and only contains
            functions that are needed for testing.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.IsConnected">
            <summary>Are we connected to the server?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.LocalPlayerId">
            <summary>Id of the local player.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.LocalPlayer">
            <summary>The local player.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.Players">
            <summary>List of players connected to the room.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.Time">
            <summary>Time data</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.OnRPC">
            <summary>RPC event handler registration.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksIRoom`2.OnPlayerJoin">
            <summary>Invoked when a player connects to the room.</summary>
        </member>
        <member name="E:KS.Reactor.Client.ksIRoom`2.OnPlayerLeave">
            <summary>Invoked when a player disconnects from the room.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIRoom`2.CallRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Calls an RPC on the server.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksITimeAdjuster">
            <summary>
            Interface for synchronizing time with the server. The room has time adjuster, and each player that
            owns entities with the transform permission also has a time adjuster, accessible via 
            <see cref="P:KS.Reactor.Client.ksClientTime.Adjuster"/> <see cref="P:KS.Reactor.Client.ksBaseRoom.Time"/> for the room and
            <see cref="M:KS.Reactor.Client.ksBaseRoom.GetTime(System.UInt32)"/> for the players.
            
            Every client frame, <see cref="P:KS.Reactor.ksTime.UnscaledDelta"/> is passed to <see cref="M:KS.Reactor.Client.ksITimeAdjuster.OnClientUpdate(System.Single)"/> to
            calculate <see cref="P:KS.Reactor.Client.ksClientTime.AdjustedUnscaledDelta"/>. <see cref="M:KS.Reactor.Client.ksITimeAdjuster.OnServerUpdate(System.Single,System.UInt64)"/> is
            called when we process a server frame.
            
            The same process happens for the player time adjusters for players who own entities with the transform 
            permission, except <see cref="M:KS.Reactor.Client.ksITimeAdjuster.OnServerUpdate(System.Single,System.UInt64)"/> is called when we receive owned-entity updates
            from that player, and <see cref="M:KS.Reactor.Client.ksITimeAdjuster.OnPlayerUpdatesStopped"/> is called when all entities owned by that player stop updating
            and we don't expect to receive more updates until they start updating again.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksITimeAdjuster.Initialize">
            <summary>Initialization</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksITimeAdjuster.OnServerUpdate(System.Single,System.UInt64)">
            <summary>Called once per server update.</summary>
            <param name="unscaledDeltaTime">
            Time delta in seconds of server simulation time (unscaled) since the last update.
            </param>
            <param name="frameNum">frame number from the server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksITimeAdjuster.OnClientUpdate(System.Single)">
            <summary>Called once per frame to adjust deltaTime to stay in sync with the server.</summary>
            <param name="deltaTime">Unscaled time delta in seconds of simulation time since the last frame.</param>
            <returns>adjusted delta time in seconds.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksITimeAdjuster.OnPlayerUpdatesStopped">
            <summary>
            Called on player time adjusters when all entities with transforms controlled by that player stop updating.
            Once this is called, <see cref="M:KS.Reactor.Client.ksITimeAdjuster.OnServerUpdate(System.Single,System.UInt64)"/> won't be called again until an entity
            controlled by the player updates again.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor">
            <summary>Smooths/predicts movement using linear interpolation and extrapolation.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.ConfigData">
            <summary>
            Contains parameters for tuning transform and property smoothing. If a smoothed property does not have a
            correction rate set, <see cref="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.PositionCorrectionRate"/> will be used if it is linearly interpolated, and
            <see cref="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.RotationCorrectionRate"/> will be used if it is spherically interpolated. If the property uses
            wrap float interpolation and has no rate set, it will use the difference between the min and the max range
            values.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.ConfigData.Default">
            <summary>Default configuration values. Values can be changed to change the defaults.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.PositionCorrectionRate">
            <summary>Position-correction interpolation rate per second.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.RotationCorrectionRate">
            <summary>Rotation-correction interpolation rate in degrees per second.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.ScaleCorrectionRate">
            <summary>Scale-correction interpolation rate per second.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.ConfigData.PredictedProperties">
            <summary>Keys are which properties to predict, and values describe how to predict them.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ConfigData.Clone">
            <summary>Creates a copy of this <see cref="T:KS.Reactor.Client.ksLinearPredictor.ConfigData"/>.</summary>
            <returns>Copy of the config.</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Config">
            <summary>
            Configurable data for customizing the the predictor. Returns null if the predictor is using the
            <see cref="P:KS.Reactor.Client.ksLinearPredictor.ConfigData.Default"/>. Assign this if you want to override the defaults.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.PropertyBehaviour">
            <summary>Describes how to predict a property.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.PropertyBehaviour.Type">
            <summary>Prediction behaviour.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.PropertyBehaviour.CorrectionRate">
            <summary>Correction interpolation rate. If less than or equal to zero,
            <see cref="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.PositionCorrectionRate"/> will be used if it is linearly interpolated, and
            <see cref="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.RotationCorrectionRate"/> will be used if it is spherically interpolated. If the property
            uses wrap float interpolation and has no rate set, it will use the difference between the min and the
            max range values.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.PropertyBehaviour.#ctor(KS.Reactor.Client.ksPredictionBehaviour,System.Single)">
            <summary>Constructor</summary>
            <param name="type">Prediction behaviour</param>
            <param name="correctionRate"><see cref="F:KS.Reactor.Client.ksLinearPredictor.PropertyBehaviour.CorrectionRate"/></param>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.RequiresController">
            <summary>Always false; the linear predictor does not require a player controller.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ToLocal(KS.Reactor.ksVector3,System.Boolean)">
            <summary>Calculate a local position from a world position using the entity parent position.</summary>
            <param name="worldPosition">World position.</param>
            <param name="useParentServerValue">Use the parent server position when calculating the local position.</param>
            <returns>Local position.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ToWorld(KS.Reactor.ksVector3,System.Boolean)">
            <summary>Calculate a world position from a local position using the entity parent position.</summary>
            <param name="localPosition">Local position.</param>
            <param name="useParentServerValue">Use the parent server position when calculating the world position.</param>
            <returns>World position.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ToLocal(KS.Reactor.ksQuaternion,System.Boolean)">
            <summary>Calculate a local rotation from a world rotation using the entity parent rotation.</summary>
            <param name="worldRotation">World rotation.</param>
            <param name="useParentServerValue">Use the parent server rotation when calculating the local rotation.</param>
            <returns>Local rotation.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ToWorld(KS.Reactor.ksQuaternion,System.Boolean)">
            <summary>Calculate a world rotation from a local rotation using the entity parent rotation.</summary>
            <param name="localRotation">Local rotation.</param>
            <param name="useParentServerValue">Use the parent server rotation when calculating the world rotation.</param>
            <returns>World rotation.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Create">
            <summary>Gets a predictor instance from the pool, or creates one if the pool is empty.</summary>
            <returns>Predictor instance</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)">
            <summary>Initializes the predictor.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <param name="player">
            Player the predictor is smoothing properties for. Null if the predictor is not smoothing player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ParentChange(KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBaseEntity)">
            <summary>
            Invoked when the Entity parent changes. This method should correct predicted values by converting the positions back to world positions
            for the removal of the old parent and then to the local position for the new parent.
            </summary>
            <param name="oldParent">Parent entity being removed.</param>
            <param name="newParent">Parent entity being added.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.OwnershipChange(System.UInt32,System.UInt32,KS.Reactor.ksOwnerPermissions,KS.Reactor.ksOwnerPermissions)">
            <summary>
            Called when the entity's owner or owner permissions change. If the transform owner changed, changes the time
            keeper to the new owner's time keeper and resets the prediction state.
            </summary>
            <param name="oldOwner">Player id of the old owner</param>
            <param name="newOwner">Player id of the new owner</param>
            <param name="oldPermissions">Old owner permissions</param>
            <param name="newPermissions">New owner permissions</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.UpdateTimeReference">
            <summary>
            Updates the time object reference to the transform owner's time object. If there is no transform owner or
            the transform owner has no time object, uses the server time object.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.UpdateTimeReference(System.UInt32)">
            <summary>
            Updates the time object reference to the transform owner's time object. If there is no transform owner or
            the transform owner has no time object, uses the server time object.
            </summary>
            <param name="transformOwnerId">
            Id of player who owns the transform. Zero if there is no transform owner.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.LogMissingTimeKeeperError(System.UInt32)">
            <summary>Logs a missing time keeper error message if one hasn't already been logged.</summary>
            <param name="transformOwnerId">
            The id of the player who owns the entity's transform. Appears in the message if it is non-zero.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Enabled">
            <summary>
            Called when the predictor is enabled. May be called zero or more times. Called after 
            <see cref="M:KS.Reactor.Client.ksLinearPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity,KS.Reactor.Client.ksBasePlayer)"/>. When an entity switches between the
            <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called
            on the one that was switched to.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Disabled">
            <summary>
            Called when the predictor is disabled. May be called multiple times. Called before <see cref="M:KS.Reactor.Client.ksLinearPredictor.Detached"/>.
            When an entity switches between the <see cref="P:KS.Reactor.Client.ksBaseEntity.NonInputPredictor"/> and 
            <see cref="P:KS.Reactor.Client.ksBaseEntity.InputPredictor"/>, this is called on the one that was switched off.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ResetInterpolation">
            <summary>
            Moves the smoothers to the latest server value and clears the frame queue. Sets a flag to check if
            correction interpolations are needed on the next 
            <see cref="M:KS.Reactor.Client.ksLinearPredictor.ClientUpdate(KS.Reactor.ksTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})"/>, unless any of the queued frames
            were teleports.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Detached">
            <summary>Resets member variables and returns the predictor to its object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.IsPredictedProperty(System.UInt32)">
            <summary>
            Does the predictor predict the property value with the given <paramref name="propertyId"/>?
            </summary>
            <param name="propertyId">Property id</param>
            <returns>True if the predictor predicts the property value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.CreateSmoother(KS.Reactor.Client.ksLinearPredictor.PropertyBehaviour)">
            <summary>Creates a smoother for a property.</summary>
            <param name="behaviour">Behaviour for property prediction.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ServerUpdate(KS.Reactor.ksReadOnlyTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">Server transform data. Null if not smoothing a transform.</param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleport">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ClientUpdate(KS.Reactor.ksTransformState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">Client transform to update with new values. Null if not smoothing a transform.</param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.UpdateTimeKeeperReference">
            <summary>Updates the time keeper reference if the time adjuster changed.</summary>
            <returns>True if the time keeper reference changed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Advance(System.UInt64,System.Single)">
            <summary>Advances the client simultion.</summary>
            <param name="frameNum">
            Server frame number to advance to. ulong. Max if we are extrapolating passed the last frame.
            </param>
            <param name="time">Time in seconds to advance to in the frame.</param>
            <returns>True if a teleport occurred.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.GetCenterOfMassPosition(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Gets the center-of-mass server position from a physics state.</summary>
            <param name="state">Physics state</param>
            <returns>Center of mass position</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.GetCenterOfMassPosition(KS.Reactor.Client.ksLinearPredictor.Frame@)">
            <summary>Gets the center-of-mass server position from a server frame.</summary>
            <param name="frame">Server frame</param>
            <returns>Center of mass position</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.Frame">
            <summary>Server frame data.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Position">
            <summary>Server position.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Rotation">
            <summary>Server rotation.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Scale">
            <summary>Server scale.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Properties">
            <summary>Server properties that changed since the last frame.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.DeltaTime">
            <summary>Server delta time in seconds since the last frame.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Num">
            <summary>Server frame number.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Teleport">
            <summary>Did the entity teleport this frame?</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Idle">
            <summary>True if there were no transform or property changes since the last frame.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.DirtyFlags">
            <summary>Transform dirty flags.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Frame.#cctor">
            <summary>Static initialization</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Frame.Initialize(KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,KS.Reactor.ksReadOnlyTransformState.DirtyFlag,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Single,System.UInt64,System.Boolean,System.Boolean)">
            <summary>Initialization</summary>
            <param name="position">Server position relative to its parent.</param>
            <param name="rotation">Server rotation relative to its parent.</param>
            <param name="scale">Server scale.</param>
            <param name="properties">
            Server properties that changed since the last frame. Null if we are not predicting properties.
            </param>
            <param name="deltaTime">Server delta time in seconds since the last frame.</param>
            <param name="num">Server frame number.</param>
            <param name="teleport">Did the entity teleport this frame?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Frame.Initialize(System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Single,System.UInt64,System.Boolean,System.Boolean)">
            <summary>Initialization</summary>
            <param name="position">Server position relative to its parent.</param>
            <param name="rotation">Server rotation relative to its parent.</param>
            <param name="scale">Server scale.</param>
            <param name="properties">
            Server properties that changed since the last frame. Null if we are not predicting properties.
            </param>
            <param name="deltaTime">Server delta time in seconds since the last frame.</param>
            <param name="num">Server frame number.</param>
            <param name="teleport">Did the entity teleport this frame?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Frame.IsDirty(KS.Reactor.ksReadOnlyTransformState.DirtyFlag)">
            <summary>Checks if a server transform property is dirty.</summary>
            <param name="flag">Flag to check.</param>
            <returns>True if the property is dirty.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Frame.CleanUp">
            <summary>Returns the object to the pool.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.ISmoother">
            <summary>Interface for smoothing a ksMultiType.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.ISmoother.Correcting">
            <summary>Are we applying correcting interpolation?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.ISmoother.ServerIdle">
            <summary>True if the server value has not changed since the last server frame.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.ISmoother.ClientIdle">
            <summary>True if the client value is not changing.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.CleanUp">
            <summary>Returns the smoother to its object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.GetValue">
            <returns>Smoothed value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.Interpolate(System.Single)">
            Interpolates towards the server value.
             <param name="t">Amount to interpolate between 0 and 1.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.CheckCorrection(KS.Reactor.ksMultiType)">
            <summary>
            Initializes a correction interpolation if the <paramref name="value"/> is different from the target
            value.
            </summary>
            <param name="value">Value to check against the target.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.UpdateCorrection(System.Single)">
            <summary>Updates the correction distance.</summary>
            <param name="deltaTime">Time in seconds since the last update.</param>
            <returns>true if the correction is not finished.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.SetInitialValue(KS.Reactor.ksMultiType)">
            <summary>Sets the initial server value.</summary>
            <param name="serverValue">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.SetNextValue(KS.Reactor.ksMultiType,System.Boolean)">
            <summary>
            Sets the next server value to interpolate to and initializes interpolation.
            </summary>
            <param name="nextValue">Next value to interpolate to.</param>
            <param name="teleport">If true, will teleport to the value instead of interpolating.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.Idle">
            <summary>Stops moving the value.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.Smoother`3">
            <summary>Smooths a templated type using a templated <see cref="T:KS.Reactor.Client.ISpace`2"/>.</summary>
            <typeparam name="Vector">The type of value being smoothed.</typeparam>
            <typeparam name="Delta">
            The type returned when subtracting a <typeparamref name="Vector"/> from another <typeparamref name="Vector"/>.
            </typeparam>
            <typeparam name="Space">The <see cref="T:KS.Reactor.Client.ISpace`2"/> implementation type.</typeparam>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.#cctor">
            <summary>Static initialization</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Correcting">
            <summary>Are we applying correction interpolation?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.ServerIdle">
            <summary>True if the server value has not changed since the last server frame.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.ClientIdle">
            <summary>True if the client value is not changing.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Create(System.Single)">
            <summary>Reuses a smoother from the object pool or creates a new one if the pool is empty.</summary>
            <param name="correctionRate">Rate per second for correction interpolation.</param>
            <returns>Smoother</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Initialize(System.Single)">
             <summary>Initializes the smoother with a correction rate.</summary>
            <param name="correctionRate">Rate per second for correction interpolation.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.CleanUp">
            <summary>Returns the smoother to the object pool.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.ServerValue">
            <summary>Server value.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Value">
            <summary>Smoothed value.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.VectorSpace">
            <summary>Vector space instance.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.GetValue">
            <returns>Smoothed value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Interpolate(System.Single)">
            <summary>Interpolates towards the server value.</summary>
            <param name="t">Amount to interpolate between 0 and 1.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.CheckCorrection(KS.Reactor.ksMultiType)">
            <summary>
            Initializes a correction interpolation if the <paramref name="value"/> is different from the target
            value.
            </summary>
            <param name="value">Value to check against the target.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.CheckCorrection(`0)">
            <summary>
            Initializes a correction interpolation if the <paramref name="value"/> is different from the target
            value.
            </summary>
            <param name="value">Value to check against the target.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.UpdateCorrection(System.Single)">
            <summary>Updates the correction distance.</summary>
            <param name="deltaTime">Time in seconds since the last update.</param>
            <returns>true if the correction is not finished.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetInitialValue(KS.Reactor.ksMultiType)">
            <summary>Sets the initial server value.</summary>
            <param name="serverValue">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetInitialValue(`0)">
            <summary>Sets the initial server value.</summary>
            <param name="serverValue">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetNextValue(KS.Reactor.ksMultiType,System.Boolean)">
            <summary>
            Sets the next server value to interpolate to and initializes interpolation.
            </summary>
            <param name="nextValue">Next value to interpolate to.</param>
            <param name="teleport">If true, will teleport to the value instead of interpolating.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetNextValue(`0,System.Boolean)">
            <summary>
            Sets the next server value to interpolate to and initializes interpolation.
            </summary>
            <param name="nextValue">Next value to interpolate to.</param>
            <param name="teleport">If true, will teleport to the value instead of interpolating.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Idle">
            <summary>Stops moving the value.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksNetCounters">
            <summary>Network counters</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksNetCounters.CounterType">
            <summary>
            Counter types.
            
            RX = Receive
            TX = Transmit
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_FRAMES">
            <summary>Receive frames</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_TOTAL">
            <summary>Receive total</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_EVENTS">
            <summary>Receive events (RPCs, Properties, Destroy, Connect/Disconnect)</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_TRANSFORM_UPDATE">
            <summary>Receive transform updates</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_TRANSFORM_FULL">
            <summary>Receive full transforms</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_INPUT">
            <summary>Receive input</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_ROOM_PROPS">
            <summary>Receive room properties</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_PLAYER_PROPS">
            <summary>Receive player properties</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_ENTITY_PROPS">
            <summary>Receive entity properties</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_MODEL_UPDATES">
            <summary>Receive model updates</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.RX_OWNER_DELTA_TIME">
            <summary>Receive owner delta times</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.TX_TOTAL">
            <summary>Transmit total</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.TX_EVENTS">
            <summary>Transmit events (RPCs)</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksNetCounters.CounterType.TX_INPUT">
            <summary>Transmit input</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksNetCounters.Add(KS.Reactor.Client.ksNetCounters.CounterType,System.UInt64)">
            <summary>Add an amount to a specific counter</summary>
            <param name="counter">Counter Type</param>
            <param name="amount">Amount</param>
        </member>
        <member name="M:KS.Reactor.Client.ksNetCounters.Get(KS.Reactor.Client.ksNetCounters.CounterType)">
            <summary>Get the amount of a specific counter</summary>
            <param name="counter">Counter Type</param>
            <returns>Amount</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksNetCounters.Clear">
            <summary>Reset all counters</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksPredictionBehaviour">
            <summary>Contains rules for how a property behaves during prediction</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksPredictionBehaviour.Types">
            <summary>Prediction rules to use on the client.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.NONE">
            <summary>Do not interpolate.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.LINEAR_FLOAT">
            <summary>Use linear interpolation on a float.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.LINEAR_VECTOR2">
            <summary>Use linear interpolation on a <see cref="T:KS.Reactor.ksVector2"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.LINEAR_VECTOR3">
            <summary>Use linear interpolation on a <see cref="T:KS.Reactor.ksVector3"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.LINEAR_COLOR">
            <summary>Use linear interpolation on a <see cref="T:KS.Reactor.ksColor"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.WRAP_FLOAT">
            <summary>
            Use linear interpolation on float and wrap onto [<see cref="F:KS.Reactor.Client.ksPredictionBehaviour.Min"/>, <see cref="F:KS.Reactor.Client.ksPredictionBehaviour.Max"/>].
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.SPHERICAL_VECTOR2">
            <summary>Use spherical interpolation on a <see cref="T:KS.Reactor.ksVector2"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.SPHERICAL_VECTOR3">
            <summary>Use spherical interpolation on a <see cref="T:KS.Reactor.ksVector3"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.QUATERNION">
            <summary>Use spherical interpolation on a <see cref="T:KS.Reactor.ksQuaternion"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Types.CLIENT">
            <summary>
            The client player controller has full control over the local property value. If the controller does not
            set the property value, the server value is used. The server is still authoritative; the client does
            not decide what other clients see.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Min">
            <summary>Minimum property value. Only used for <see cref="F:KS.Reactor.Client.ksPredictionBehaviour.Types.WRAP_FLOAT"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Max">
            <summary>Maximum property value. Only used for <see cref="F:KS.Reactor.Client.ksPredictionBehaviour.Types.WRAP_FLOAT"/>.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Type">
            <summary>Type of smoothing to use.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictionBehaviour.#ctor(KS.Reactor.Client.ksPredictionBehaviour.Types,System.Single,System.Single)">
            <summary>Constructor</summary>
            <param name="type">Type of smoothing to use during prediction</param>
            <param name="min">Min value use for <see cref="F:KS.Reactor.Client.ksPredictionBehaviour.Types.WRAP_FLOAT"/></param>
            <param name="max">Max value use for <see cref="F:KS.Reactor.Client.ksPredictionBehaviour.Types.WRAP_FLOAT"/></param>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictionBehaviour.op_Equality(KS.Reactor.Client.ksPredictionBehaviour,KS.Reactor.Client.ksPredictionBehaviour)">
            <summary>Checks if two prediction behaviours are equal.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the behaviours are the same.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictionBehaviour.op_Inequality(KS.Reactor.Client.ksPredictionBehaviour,KS.Reactor.Client.ksPredictionBehaviour)">
            <summary>Checks if two prediction behaviours are not equal.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the behaviours are not the same.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictionBehaviour.Equals(System.Object)">
            <summary>Checks if the prediction behaviour is equal to an object.</summary>
            <param name="obj">obj to compare with.</param>
            <returns>True if this is equal to the object.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictionBehaviour.GetHashCode">
            <summary>Gets the hash code.</summary>
            <returns>hash code.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksPredictorUtils">
            <summary>Client-side predictor utility.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.UpdateController(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksTransformState,System.Single,System.Single,KS.Reactor.ksInput)">
            <summary>Updates a <paramref name="transform"/> based on a player controller update.</summary>
            <param name="entity">Entity with player controller to update.</param>
            <param name="transform">Transform to update.</param>
            <param name="unscaledDeltaTime">Delta time in seconds, unscaled by <see cref="P:KS.Reactor.ksTime.TimeScale"/>.</param>
            <param name="timeScale">Time scale</param>
            <param name="input">Input for the controller. If null, the current input will be used.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.ApplyRigidBodyMotion(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksTransformState,System.Single,KS.Reactor.ksSweepSlideParams)">
            <summary>
            Applies motion to an entity from rigid body physics, optionally checking for collisions and sliding.
            </summary>
            <param name="entity">Entity to apply rigid body motion to.</param>
            <param name="transform">Transform to update.</param>
            <param name="deltaTime">Amount of time in seconds to simulate.</param>
            <param name="sweepSlideParams">
            If not null and the rigid body is dynamic, checks for collisions using sweep-and-slide movement with these
            parameters. <see cref="P:KS.Reactor.ksOverlapParams.Entity"/>, <see cref="!:ksBasePhysicsQueryParams.ExcludeEntity"/>,
            <see cref="!:ksBasePhysicsQueryParams.Filter"/>, <see cref="!:ksBasePhysicsQueryParams.Flags"/> will be
            overwritten to use simulation filter rules. If <see cref="F:KS.Reactor.ksSweepSlideParams.CollideCallback"/> is null, a
            callback will be assigned to eliminate the velocity in the direction of the surface normal.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.ApplyRigidBodyMotion(KS.Reactor.ksIRigidBody,System.Single,KS.Reactor.ksVector3,KS.Reactor.ksVector3@,KS.Reactor.ksQuaternion@)">
            <summary>Applies rigid body motion to a rigid body without checking for collisions.</summary>
            <param name="rigidBody">Rigid body to apply motion to.</param>
            <param name="deltaTime">Amount of time in seconds to simulate.</param>
            <param name="gravity">Gravity</param>
            <param name="position">Position to update.</param>
            <param name="rotation">Rotation to update.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.ApplyRigidBody2DMotion(KS.Reactor.ksIRigidBody2D,System.Single,KS.Reactor.ksVector2,KS.Reactor.ksVector3@,KS.Reactor.ksQuaternion@)">
            <summary>Applies rigid body motion to a 2D rigid body without checking for collisions.</summary>
            <param name="rigidBody">Rigid body to apply motion to.</param>
            <param name="deltaTime">Amount of time in seconds to simulate.</param>
            <param name="gravity">Gravity</param>
            <param name="position">Position to update.</param>
            <param name="rotation">Rotation to update.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.HandleCollision(KS.Reactor.ksSweepResult,KS.Reactor.ksSweepSlideParams,KS.Reactor.ksVector3,KS.Reactor.ksSweepSlideParams.CallbackStates)">
            <summary>
            Called during sweep-and-slide movement when a sweep hits something. Removes velocity in the direction of
            the surface normal.
            </summary>
            <param name="hit">Sweep hit</param>
            <param name="args">Sweep and slide parameters</param>
            <param name="direction">Sweep direction</param>
            <param name="state">State indicating if there will be another sweep.</param>
            <returns>True to continue sliding</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.ApplyChildTranformUpdates(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>
            Use old and new transform values to apply predictor changes to entity children.
            </summary>
            <param name="oldPosition"></param>
            <param name="newPosition"></param>
            <param name="oldRotation"></param>
            <param name="newRotation"></param>
        </member>
        <member name="T:KS.Reactor.Client.ksReadOnlyTransform2D">
            <summary>
            Wraps a <see cref="T:KS.Reactor.ksIReadOnlyTransform"/> and provides a 2D view of the data.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksReadOnlyTransform2D.Position">
            <summary>Position</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksReadOnlyTransform2D.Rotation">
            <summary>Rotation in degrees.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksReadOnlyTransform2D.RotationRadians">
            <summary>Rotation in radians.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksReadOnlyTransform2D.Scale">
            <summary>Scale</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksReadOnlyTransform2D.#ctor(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Constructor</summary>
            <param name="transform">Transform to provide a 2D view of.</param>
        </member>
        <member name="E:KS.Reactor.Client.ksRUDPConnection.OnDisconnect">
            <summary>
            Event invoked during a disconnect of an established connection.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksRUDPConnection.IsConnected">
            <summary>
            Check if a connection to the server is open.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksRUDPConnection.ReadProgress">
            <summary>
            Get the progress of the current read operation.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksRUDPConnection.WriteProgress">
            <summary>
            Get the progress of the current write operation.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.Connect(System.String,System.UInt16,KS.Reactor.Client.ksConnection.ConnectHandler,System.Object)">
            <summary>
            Begin an asynchronous connection to a remote server accepting Reactor RUDP connections.
            </summary>
            <param name="host">Remote host</param>
            <param name="port">Remote port</param>
            <param name="callback">Callback which is invoked when the connection is established.</param>
            <param name="asyncState">User state to return in the callback.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.HandleAsyncConnect(KS.Reactor.Secret.RUDPSession,System.Net.Sockets.SocketError)">
            <summary>
            Handle the asyn connection result.
            </summary>
            <param name="session">RUDP session that is completing the connection attempt.</param>
            <param name="result">Success or error state of the connection attempt.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.Disconnect(System.Boolean)">
            <summary>
            Disconnect from the remote server.
            </summary>
            <param name="immediate">
            If false, queued write requests will be sent before disconnecting. During this time, new writes 
            will not be permitted.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.Read(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            <summary>
            Create an asynchronous request to read data from the connection.
            </summary>
            <param name="segment">Buffer segement to store data in.</param>
            <param name="callback">Callback to invoke when the read attempt completes.</param>
            <param name="asyncState">User state to return in the callback.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.AsyncRead(KS.Reactor.Client.ksConnection.IOOperation)">
            <summary>
            Begin an async read request.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.HandleAsyncRead(KS.Reactor.Secret.RUDPSession,System.Net.Sockets.SocketError)">
            <summary>
            Handle the result of an async read request.
            </summary>
            <param name="session">RUDP session completing the read request.</param>
            <param name="result">Success or error state of the read request.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.Write(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            <summary>
            Create an asynchronous request to write data on the connection.
            </summary>
            <param name="segment">Buffer segement containing the data to write.</param>
            <param name="callback">Callback to invoke when the write attempt completes.</param>
            <param name="asyncState">User state to return in the callback.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.AsyncWrite(KS.Reactor.Client.ksConnection.IOOperation)">
            <summary>
            Begin an async write request.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.HandleAsyncWrite(KS.Reactor.Secret.RUDPSession,System.Net.Sockets.SocketError)">
            <summary>
            Handle the result of an async write request.
            </summary>
            <param name="session">RUDP session completing the write request.</param>
            <param name="result">Success or error state of the write request.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksRUDPConnection.Disconnect(System.Net.Sockets.SocketError)">
            <summary>
            Handle a disconnection error/completion event.
            </summary>
            <param name="error">Reason for the disconnect.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksService">
            <summary>Main entry point to connect to the service.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksService.RoomListCallback">
            <summary>Callback for <see cref="M:KS.Reactor.Client.ksService.GetServers(System.String,System.String,KS.Reactor.Client.ksService.RoomListCallback)"/>.</summary>
            <param name="roomList">List of public rooms.</param>
            <param name="error">Error message. Null if there was no error.</param>
        </member>
        <member name="P:KS.Reactor.Client.ksService.AppDataPath">
            <summary>Path to write app data to.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.KinematicSoupPath">
            <summary>Path to KinematicSoup folder.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.StaticModelPath">
            <summary>Path to static model.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.ModelChecksum">
            <summary>Model checksum</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.ModelData">
            <summary>Model data</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.Coroutines">
            <summary>Coroutine manager</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.InputManager">
            <summary>Input manager</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.PlayerTimeAdjusterFactory">
            <summary>
            The factory for creating <see cref="T:KS.Reactor.Client.ksITimeAdjuster"/>s for players who own entities with the transform
            permission. If null, a <see cref="T:KS.Reactor.Client.ksTimeKeeper"/> will be created.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.WebRequestFactory">
            <summary>Factory for providing custom <see cref="T:KS.Reactor.ksIWebRequest"/> implementations.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.PlayerAPI">
            <summary>Player account API</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksService.Rooms">
            <summary>List of rooms we are connected or connecting to.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksService.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksService.CoroutineWebRequestHandler(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            <summary>
            This alternative web request handler manages the request with the coroutine manager therefore ensuring the
            completion handler is called on the main update thread.
            </summary>
            <param name="url">URL</param>
            <param name="headers">additional request headers</param>
            <param name="method">request method</param>
            <param name="data">post request data</param>
            <param name="onComplete">request callback</param>
            <param name="asyncState">state object returned in the callback</param>
            <returns>Web request</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksService.Disconnect(System.Boolean)">
            <summary>Disconnects from all rooms.</summary>
            <param name="immediate">if false, waits for pending writes before disconnecting.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksService.JoinRoom(KS.Reactor.Client.ksBaseRoom,KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[])">
            <summary>Connects to a room.</summary>
            <param name="room">room to join.</param>
            <param name="session">player session credentials.</param>
            <param name="authArgs">authentication arguments</param>
            <returns>
            false if a connection attempt was not made because of invalid parameters or because we're
            already connected or connecting to the room.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksService.HasConnection(KS.Reactor.Client.ksBaseRoom)">
            <summary>Test if the service already has a connection to a room</summary>
            <param name="room">Room</param>
            <returns>True if we are connected to an equivalent room.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksService.LeaveRoom(KS.Reactor.Client.ksBaseRoom,System.Boolean)">
            <summary>Disconnects from a room.</summary>
            <param name="room">room to leave.</param>
            <param name="immediate">if false, waits for pending writes before disconnecting.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksService.GetServers(System.String,System.String,KS.Reactor.Client.ksService.RoomListCallback)">
            <summary>Request a list of running server instances</summary>
            <param name="url">url</param>
            <param name="binding">image binding</param>
            <param name="callback">callback</param>
        </member>
        <member name="M:KS.Reactor.Client.ksService.Update(System.Single,System.Single)">
            <summary>Called each frame.</summary>
            <param name="unscaledDeltaTime">
            simulated time in seconds since the last update, unscaled by time scaling.
            </param>
            <param name="realDeltaTime">
            real time in seconds since the last update. If less than zero, will be calculated.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksService.PostUpdate">
            <summary>
            Called every frame after scripts are updated. Calls <see cref="M:KS.Reactor.Client.ksBaseRoom.PostUpdate"/> on the rooms.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksService.SetStaticModel(System.IO.Stream,System.Boolean)">
            <summary>Set static model.</summary>
            <param name="modelStream">modelStream to read model from</param>
            <param name="saveToFile">If true, saves the model to a <see cref="P:KS.Reactor.Client.ksService.StaticModelPath"/>.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksTCPConnection">
            <summary>Network stream connection using sockets and the TCP protocol.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksTCPConnection.ConfigSettings">
            <summary>Configuration options for TCP connections</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.Config">
            <summary>Configuration settings used for new TCP connections.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.IsConnected">
            <summary>Check if a connection to the server is open.</summary>
            <returns>True if connected to the server.</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.ReadProgress">
            <summary>Get the progress of the current read operation.</summary>
            <returns>Read progress</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.WriteProgress">
            <summary>Get the progress of the current write operation.</summary>
            <returns>Write progress</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Connect(System.String,System.UInt16,KS.Reactor.Client.ksConnection.ConnectHandler,System.Object)">
            <summary>Establish a connection to a server.</summary>
            <param name="host">server host name</param>
            <param name="port">server port</param>
            <param name="callback">callback to invoke when the connection attempt completes</param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Disconnect(System.Boolean)">
            <summary>Disconnect from the server.</summary>
            <param name="immediate">
            If this is false, then queued write operations will complete before disconnecting.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Read(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            <summary>Read data from the connection into a stream buffer segment.</summary>
            <param name="segment">segment of a larger stream buffer</param>
            <param name="callback">callback to invoke when the read operation completes</param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Write(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            <summary>Write data to the socket.</summary>
            <param name="segment">segment of a larger stream buffer</param>
            <param name="callback">callback to invoke when the write operation completes</param>
            <param name="asyncState">asynchronous state</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.HandleAsyncConnect(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>Handle a connect event from the TCP socket by calling the connect handler.</summary>
            <param name="socket">socket that attempted the connection</param>
            <param name="args">async event argurments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.IOExecute(KS.Reactor.Client.ksConnection.IOOperation)">
            <summary>Execute an asynchronous IO operation.</summary>
            <param name="op">IO operation</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.IOContinue(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>Check the async event arguments and call the appropriate async action on the socket.</summary>
            <param name="args">async event argurments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.IOComplete(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>Handle the completion of a socket action.</summary>
            <param name="socket">socket attempted the IO action</param>
            <param name="args">async event argurments</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Disconnect(System.Net.Sockets.SocketError)">
            <summary>Handle a disconnection error/completion event.</summary>
            <param name="error">Reason for disconnect</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.DiagnoseConnectionFailure(System.String,System.UInt16)">
            <summary>Diagnose Connection Failure to the server.</summary>
            <param name="host">host</param>
            <param name="port">port</param>
            <returns>error (null if no connection errors could be determined)</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksTimeKeeper">
            <summary>
            Smoothly adjusts client time deltas to keep in sync with the server. Controls time values that determine how far
            predictors should interpolate/extrapolate the server frame data.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.ksTimeKeeper.Frame">
            <summary>Server frame timing data.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksTimeKeeper.Frame.DeltaTime">
            <summary>Delta time of frame in seconds.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksTimeKeeper.Frame.Num">
            <summary>Frame number</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.Frame.#ctor(System.Single,System.UInt64)">
            <summary>Constructor</summary>
            <param name="deltaTime">delta time in seconds.</param>
            <param name="num">frame number.</param>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.Drift">
            <summary>
            How far ahead or behind in seconds we've drifted from the target latency. Each server frame received
            decreases this number.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.TargetLatency">
            <summary>
            How far behind each server frame we try to be when that server frame arrives. Increasing reduces the
            likelyhood of getting ahead of the latest server frame, which increases client simulation accuracy as we
            won't have to extrapolate object transforms as often, but it also increases latency. By default this is set
            to zero to favour the lowest latency possible.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.MinAdjustmentDuration">
            <summary>
            Minimum duration of time adjustment in seconds. Time adjustments are applied over multiple frames to make
            the adjustment smooth. The adjustment duration is the larger of this amount or twice the time being
            corrected, unless the time correction exceeds max drift, in which case we do a near-instant time adjustment.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.DriftThreshold">
            <summary>
            Drift theshold in seconds to try keep the drift within. Smaller values will trigger time adjustments more
            frequently.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.NumDriftExceeds">
            <summary>
            Number of consecuitive drift samples exceeding the threshold needed to trigger time correction.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.MaxDrift">
            <summary>
            Max drift ahead or behind the server in seconds before applying a near-instant time correction. The
            adjustment still takes multiple frames so if more server frames arrive before we finish the adjustment, we
            increase the time correction and time adjustment duration to include them rather than doing multiple instant
            adjustments.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.Extrapolating">
            <summary>Are we extrapolating passed the last frame?</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.FrameNum">
            <summary>
            Frame number for the server frame we are currently interpolating towards. ulong.MaxValue if we are extrapolating.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.TimeOffset">
            <summary>How long in seconds we are extrapolating or interpolating in the current frame.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.LastFrameNum">
            <summary>
            Frame number for the server frame we were interpolating towards last update. ulong.MaxValue if we were extrapolating.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.LastTimeOffset">
            <summary>How long in seconds we were extrapolating or interpolating last update.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.TimeCorrection">
            <summary>Amount in seconds time is being corrected by.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.UpdatesStopped">
            <summary>
            True when we are not expecting <see cref="M:KS.Reactor.Client.ksTimeKeeper.OnServerUpdate(System.Single,System.UInt64)"/> to be called with owner delta 
            times because entities owned by the player this time keeper is for are not updating. While true, will not 
            extrapolate passed the last server frame.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.Restrainer">
            <summary>
            Time restrainer that slows down and eventually stops time when we go too long without receiving any server
            updates. Can be set to null to disable this behaviour.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.Initialize">
            <summary>Resets/clears timing data.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.OnServerUpdate(System.Single,System.UInt64)">
            <summary>
            Called once per server update. Updates drift and checks if we need to initiate a time correction.
            </summary>
            <param name="unscaledDeltaTime">
            Time delta in seconds of server simulation time (unscaled) since the last update.
            </param>
            <param name="frameNum">Frame number from the server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.OnClientUpdate(System.Single)">
            <summary>
            Called once per frame to adjust deltaTime to stay in sync with the server. Advances time offset and frame
            num for predictor interpolation/extrapolation.
            </summary>
            <param name="deltaTime">Unscaled time delta in seconds of simulation time since the last frame.</param>
            <returns>adjusted delta time in seconds.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.OnPlayerUpdatesStopped">
            <summary>
            Prevents extrapolating passed the last server frame until <see cref="M:KS.Reactor.Client.ksTimeKeeper.OnServerUpdate(System.Single,System.UInt64)"/> is
            called.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.UpdateExceedCount(System.Single)">
            <summary>Updates exceed count (number of consecuitive drifts exceeded the threshold).</summary>
            <param name="drift">How far ahead of behind the target latency we've drifted in seconds.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.Advance(System.Single)">
            <summary>Advances the current frame and interpolation/extrapolation time.</summary>
            <param name="deltaTime">deltaTime in seconds to advance by.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.GetAdjustment(System.Single)">
            <summary>Calculates time adjusted for time correction.</summary>
            <param name="time">how long we have been adjusting time.</param>
            <returns>amount to adjust time by.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.AdjustDeltaTime(System.Single)">
            <summary>
            Adjusts <paramref name="deltaTime"/> for time correction. Time is adjusted using a sine wave so the
            adjustment smoothly starts and stops.
            </summary>
            <param name="deltaTime">Time delta to adjust.</param>
            <returns>adjusted delta time.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.InitTimeCorrection(System.Single)">
            <summary>Initializes time correction.</summary>
            <param name="timeCorrection">time correction in seconds.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksTimeKeeper.CheckTimeCorrection(System.Int32)" -->
        <member name="T:KS.Reactor.Client.ksTimeRestrainer">
            <summary>
            Simple time adjuster that slows down and eventually stops incrementing time after long periods with no
            updates from the server.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeRestrainer.SlowTime">
            <summary>
            Real time in seconds after which extrapolation rate slows down if no server updates are received.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeRestrainer.MaxTime">
            <summary>Real time in seconds after which extrapolation stops if no server updates are received.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeRestrainer.ExtrapolationTime">
            <summary>How long we've been extrapolating without a server update in seconds.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksTimeRestrainer.UpdatesStopped">
            <summary>
            True when we are not expecting to receive any server time updates because entities owned by the player this
            time restrainer is for are not updating. Extrapolation time will not increase while this is true.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.#ctor(System.Single,System.Single)">
            <summary>Constructor</summary>
            <param name="slowTime">
            Time in seconds after which extrapolation rate slows down if no server updates are received.
            </param>
            <param name="maxTime">Time in seconds after which extrapolation stops if no server updates are received.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.Initialize">
            <summary>Clears the extrapolation time.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.OnServerUpdate(System.Single,System.UInt64)">
            <summary>Called once per server update.</summary>
            <param name="unscaledDeltaTime">
            Time delta in seconds of server simulation time (unscaled) since the last update.
            </param>
            <param name="frameNum">Frame number from the server.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.OnClientUpdate(System.Single)">
            <summary>
            Called once per frame to adjust <paramref name="deltaTime"/> to stay in sync with the server.
            </summary>
            <param name="deltaTime">Unscaled time delta in seconds of simulation time since the last frame.</param>
            <returns>adjusted delta time in seconds.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.OnPlayerUpdatesStopped">
            <summary>
            Stops tracking extrapolation time until <see cref="M:KS.Reactor.Client.ksTimeRestrainer.OnServerUpdate(System.Single,System.UInt64)"/> is called.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.AdjustTime(System.Single)">
            <summary>
            Adjusts extrapolation time to slow down extrapolation rate when extrapolation runs longer than <see cref="F:KS.Reactor.Client.ksTimeRestrainer.m_slowTime"/>.
            </summary>
            <param name="time">duration of extrapolation.</param>
            <returns>adjusted extrapolation time.</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksVersion">
            <summary>Version number consisting of major, minor, revision, and build.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Current">
            <summary>Current API version.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksVersion.Precision">
            <summary>Which revision numbers to check for version comparisons.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksVersion.Precision.MAJOR">
            <summary>Check only the major version numbers.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksVersion.Precision.MINOR">
            <summary>Check the major and minor version numbers.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksVersion.Precision.REVISION">
            <summary>Check the major, minor, and revision version numbers.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksVersion.Precision.BUILD">
            <summary>Check all the version numbers.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Major">
            <summary>Major number</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Minor">
            <summary>Minor number</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Revision">
            <summary>Revision number</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Build">
            <summary>Build number</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Constructor</summary>
            <param name="major">major number</param>
            <param name="minor">minor number</param>
            <param name="revision">revision number</param>
            <param name="build">build number</param>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.FromString(System.String)">
            <summary>Constructs a <see cref="T:KS.Reactor.Client.ksVersion"/> from a version string.</summary>
            <param name="versionString">
            Version string consisting of major, minor, revision, and build seperated by '.' or '-'.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Parse(System.String)">
            <summary>Sets version numbers by parsing a version string.</summary>
            <param name="versionString">Version string to parse.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.CreateException(System.String)">
            <summary>Creates an <see cref="T:System.ArgumentException"/>.</summary>
            <param name="version">version string that triggered the exception.</param>
            <returns>Exception</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.ToString">
            <summary>Gets the version string.</summary>
            <returns>version string</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_Equality(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            <summary>Checks if two versions are the same.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>true if the versions are the same.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_Inequality(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            <summary>Checks if two versions are different.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>true if the versions are different.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_LessThan(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            <summary>Checks if a version is older than another.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>true if <paramref name="lhs"/> is older than <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_LessThanOrEqual(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            <summary>Checks if a version is older or equal to another.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>true if <paramref name="lhs"/> is older or equal to <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_GreaterThan(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            <summary>Checks if a version is newer than another.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>true if <paramref name="lhs"/> is newer than <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_GreaterThanOrEqual(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            <summary>Checks if a version is newer or equal to another.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>true if <paramref name="lhs"/> is newer or equal to <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Equals(System.Object)">
            <summary>Checks if this version is equal to an object.</summary>
            <param name="obj">obj to compare with.</param>
            <returns>true if this version is equal to the object.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Equals(KS.Reactor.Client.ksVersion)">
            <summary>Checks if the version is the same as another.</summary>
            <param name="other">other to compare with.</param>
            <returns>true if the versions are the same.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Equals(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion.Precision)">
            <summary>Checks if the version is the same as another up to the specified precision level.</summary>
            <param name="other">Other version to compare with.</param>
            <param name="precision">Which version numbers to compare.</param>
            <returns>True if the versions are the same up the to specified precision level.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Compare(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion.Precision)">
            <summary>Compares the version with another version up to the specified precision level.</summary>
            <param name="other">Other version to compare with.</param>
            <param name="precision">Which version numbers to compare.</param>
            <returns>
            Negative value if this version is lower than the other version, positive value if is higher, and zero if
            they are the same up to the specified precision level.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.GetHashCode">
            <summary>Gets the hash code.</summary>
            <returns>hash code</returns>
        </member>
        <member name="T:KS.Reactor.Client.PropertySync">
            Holds properties and provides methods for updating properties.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.LocalChangedProperties">
            List of properties changed by the local property owner that need to be sent to the server. This list is
            updated when UpdateLocalChangedProperties is called.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.ChangedValues">
            Smoothed property values from the server that have changed since the last server frame, indexed by property id.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.ClientValues">
            Smoothed property values, indexed by property id.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.ServerValues">
            Server property values. Only contains values for predicted properties or, if the local player owns the
            properties, properties that were set locally.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.Index">
            Index of the property sync in the room's list of property syncs with smoothed properties. -1 if it is not in
            the list.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.Predictor">
            Predictor for smoothing property values. Cannot be set to a non-null value if the local player owns the
            properties.
        </member>
        <member name="F:KS.Reactor.Client.PropertySync.m_propertyChangeEventMap">
            Invoked when a room property changes. Indexed by property id.
        </member>
        <member name="F:KS.Reactor.Client.PropertySync.m_propertyMap">
            Properties
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.LocallyOwned">
            Can the local player set property values that will be synced to the server? If true, any properties that were
            set locally are controlled by the client and will not update when they change on the server, and 
            GetPropertyServerValue must be called to get the server value. The property predictor is always null when
            this is true.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.#ctor(System.Object)">
            Constructor
            
            @param   object owner - the room, sync object, or player that owns the property sync.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.GetPropertyServerValue(System.UInt32)">
            Gets property server value.
            
            @param   uint propertyId
            @return  ksMultiType
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.SetServerProperty(System.UInt32,KS.Reactor.ksMultiType,System.Collections.Generic.Queue{KS.Reactor.Client.IChangeEvent})">
            <summary>
            Sets a server property value. If the property is not a predicted property or an owned property set by the
            local player, or if it is a new property, also updates the value in the client property map.
            </summary>
            <param name="propertyId">Id of property to set.</param>
            <param name="property">Property value.</param>
            <param name="changeEventQueue">
            Queue to add property change events to. A change event is added if there is a property change event handler
            for the property, the property is not using prediction or is a new property, and the new value is different
            from the old value.If null, the on property change event is invoked.
            </param>
            <returns>True if the property is a predicted property</returns>
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.OwnerSet(System.UInt32,KS.Reactor.ksMultiType@,KS.Reactor.ksMultiType@)">
            Called when the local player who owns the properties sets a property. Adds the old property to the server
            values dictionary if it isn't already in it, and invokes the property change event if the new and old values
            are different.
            
            @param   uint propertyId
            @param   ref ksMultitype oldValue of the property.
            @param   ref ksMultiType newValue of the property.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.ServerUpdate">
            Calls ServerUpdate on the predictor with properties whose values have changed since the last server frame.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.PropertySync.SmoothUpdate(System.Collections.Generic.Queue{KS.Reactor.Client.IChangeEvent})" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.PropertySync.Update(System.Collections.Generic.Queue{KS.Reactor.Client.IChangeEvent})" -->
        <member name="M:KS.Reactor.Client.PropertySync.UpdateLocalChangedProperties">
            Updates the list of locally changed properties to contain properties that were changed by the local player
            since the last time this was called. Does nothing if the local player does not own the properties.
            
            @return  bool true if there are locally changed properties since the last time this was called.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.PropertySync.RestoreServerValues(System.Collections.Generic.Queue{KS.Reactor.Client.IChangeEvent})" -->
        <member name="M:KS.Reactor.Client.PropertySync.Clear">
            Clears all properties.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.Set(System.UInt32,KS.Reactor.ksMultiType,System.Collections.Generic.Queue{KS.Reactor.Client.IChangeEvent})">
            <summary>Sets a property in the client property map.</summary>
            <param name="propertyId">Id of property to set</param>
            <param name="value">Property value to set</param>
            <param name="changeEventQueue">
            Queue to add change event to if the property changed. If null, the on property change event is invoked.
            </param>
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.InvokePropertyChangeEvent(System.UInt32,KS.Reactor.ksMultiType,KS.Reactor.ksMultiType)">
            <summary>Invokes the property change event.</summary>
            <param name="propertyId">Id of the changed property.</param>
            <param name="oldValue">Old property value</param>
            <param name="newValue">New property value</param>
        </member>
        <member name="T:KS.Reactor.Client.ReusableIdTracker">
            <summary>Tracks uint ids that are in-use and ids that were recycled for reuse.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ReusableIdTracker.NextId">
            <summary>Gets the next available id.</summary>
            <returns>Id</returns>
        </member>
        <member name="M:KS.Reactor.Client.ReusableIdTracker.Recycle(System.UInt32)">
            <summary>Recycles an id so it can be resused.</summary>
            <param name="id">Id to recycle</param>
            <returns>False if the id could not be recycled because it was not in use.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ReusableIdTracker.Reset">
            <summary>Clears all used ids and makes the next id 1.</summary>
        </member>
        <member name="T:KS.Reactor.Client.WebServerAPI">
            A static class for communicating with Reactor server managers
        </member>
        <member name="P:KS.Reactor.Client.WebServerAPI.WebRequestFactory">
            Factory for creating ksIWebRequests.
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.GetServers(System.String,System.String,KS.Reactor.Client.ksService.RoomListCallback)">
            Coroutine for requesting a list of public instances
            
            @param   string - url of the publish service
            @param   string - image binding string [company id].[project id].[image id]
            @param   RoomListCallback callback
            @return  IEnumerator
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.AsyncRequest(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            Async request
            
            @param   string - URL
            @param   WebHeaderCollection - additional request headers
            @param   string - request method
            @param   ksJSON - post request data
            @param   ksWebResponse.Handler - request callback
            @param   object - state object returned in the callback
            @return  IEnumerator
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.SyncRequest(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            Synchronous request
            
            @param   string - URL
            @param   WebHeaderCollection - additional request headers
            @param   string - request method
            @param   ksJSON - post request data
            @param   ksWebResponse.Handler - request callback
            @param   object - state object returned in the callback
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.AsyncUploadRequest(System.String,System.IO.FileInfo[],KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler)">
            Async file upload request
            
            @param   string - url
            @param   FileInfo[] - list of files to upload
            @param   ksJSON - request data
            @param   RequestCallback - response callback
            @return  IEnumerator
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksEntity">
            <summary>
            Engine agnostic stub implementation of <see cref="T:KS.Reactor.Client.ksBaseEntity"/>. Prefabs/types and collisions are not
            implemented.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksEntity.PredictorFactory">
            <summary>Factory for creating a predictor.</summary>
            <returns>Predictor</returns>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksEntity.TransformUpdater">
            <summary>
            Callback to update a locally-owned entity's transform when it's time to send a transform update to the
            server. If you set a value on <paramref name="transform"/>, it will set a dirty flag for that value and
            generate an update to send to the server, even if that value did not change. You should check if the value
            changed before setting a value.
            </summary>
            <param name="entity">Entity to get transform update for.</param>
            <param name="transform">Transform to update.</param>
        </member>
        <member name="F:KS.Reactor.Client.Adaptors.ksEntity.InputPredictorFactory">
            <summary>
            Factory for creating predictors for entities with player controllers that use input prediction.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.Adaptors.ksEntity.NonInputPredictorFactory">
            <summary>
            Factory for creating predictors for entities without player controllers that use input prediction.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntity.Room">
            <summary>Room the entity is in.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntity.Scripts">
            <summary>List of scripts attached to the entity.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntity.OwnedTransformUpdater">
            <summary>
            Callback to call if the entity is owned-locally with the transform permission to get a transform update to
            send to the server.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.#ctor">
            <summary>Default constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.AttachScripts">
            <summary>Not implemented.</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.InitializeScripts">
            <summary>Initializes entity scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.Destroy(KS.Reactor.Client.ksDestroyReason)">
            <summary>Detaches all scripts and cleans up the entity for reuse.</summary>
            <param name="reason">The reason the entity was destroyed.</param>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Invoke managed RPCs on all entity scripts.</summary>
            <param name="rpcId">RPC ID</param>
            <param name="rpcArgs">RPC arguments</param>
            <returns>True if the method invoked any RPC handler</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.Adaptors.ksEntity.CreateInputPredictor(KS.Reactor.Client.ksIPredictor@)" -->
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.CreateNonInputPredictor(KS.Reactor.Client.ksIPredictor@)">
            <summary>Calls an RPC on this entity on the server.</summary>
            <param name="rpcId">rpcId of rpc to call.</param>
            <param name="arguments">arguments to send to server.</param>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.GetTransformUpdate(KS.Reactor.ksTransformState)">
            <summary>
            Called on locally owned entities with the transform permission. Calls the
            <see cref="P:KS.Reactor.Client.Adaptors.ksEntity.OwnedTransformUpdater"/> if there is one to get a transform update to send to the server.
            </summary>
            <param name="transform"></param>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksEntityScript">
            <summary>Base class for scripts that can be attached to entities.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Entity">
            <summary>Entity this script is attached to.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Room">
            <summary>Room the entity is in.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Time">
            <summary>Server time and local frame delta.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Properties">
            <summary>Entity properties</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Transform">
            <summary>Entity transform</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Transform2D">
            <summary>2D entity transform</summary>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksPlayer">
            <summary>Engine agnostic implementation of <see cref="T:KS.Reactor.Client.ksBasePlayer"/>.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayer.Room">
            <summary>Room the player is in.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayer.Scripts">
            <summary>List of scripts attached to the player.</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksPlayer.#ctor(System.UInt32)">
            <summary>Constructor</summary>
            <param name="id">id of the player.</param>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksPlayer.InitializeScripts">
            <summary>Initializes player scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksPlayer.Destroy">
            <summary>Detaches all scripts.</summary>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksPlayerScript">
            <summary>Base class for scripts that can be attached to players.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Player">
            <summary>Player this script is attached to.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Room">
            <summary>Room the player is in.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Time">
            <summary>Server time and local frame delta.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Properties">
            <summary>Player properties</summary>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksRoom">
            <summary>
            Engine agnostic stub implementation of <see cref="T:KS.Reactor.Client.ksBaseRoom"/>. Prefabs/types and physics are not implemented.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksRoom.UpdateHandler">
            <summary>Update event handler.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.Scripts">
            <summary>List of scripts attached to the room.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.Physics">
            <summary>This is not implemented and will be null.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.Gravity">
            <summary>Gravity</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.OnUpdate">
            <summary>Delegates are invoked every update in sorted order of indices.</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.#ctor(KS.Reactor.ksRoomInfo)">
            <summary>Constructor</summary>
            <param name="roomInfo">Determines where we connect.</param>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.CreatePlayer(System.UInt32)">
            <summary>Creates a player.</summary>
            <param name="id">id of player.</param>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.CreateEntity">
            <summary>Creates an entity.</summary>
            <returns>Entity</returns>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.LoadPlayerScripts(KS.Reactor.Client.Adaptors.ksPlayer)">
            <summary>Loads and attaches player scripts to a player. This is not implemented.</summary>
            <param name="player">player to attach scripts to.</param>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.InitializeScripts">
            <summary>Initializes room scripts.</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.UpdateScripts">
            <summary>Calls registered update handlers.</summary>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Invoke managed RPCs on all room scripts.</summary>
            <param name="rpcId">RPC ID</param>
            <param name="rpcArgs">RPC arguments</param>
            <returns>True if the method invoked any RPC handler</returns>
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.SpawnEntity(KS.Reactor.ksSpawnParams,KS.Reactor.ksMultiType[])">
            <summary>
            Spawns an entity on the client and sends a request to the server to spawn the entity. The entity will have
            a temporary spawn id until the server validates the spawn. If the server denies the spawn, the entity will
            be destroyed.
            </summary>
            <param name="spawnParams">Spawn parameters. Must have a non-zero asset id.</param>
            <param name="args">
            Additional arguments to send to the server. These will be available in the server player spawn entity event.
            </param>
            <returns>Spawned entity</returns>
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksRoomScript">
            <summary>Base class for scripts that can be attached to rooms.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoomScript.Room">
            <summary>Room the script is attached to.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoomScript.Time">
            <summary>Server time and local frame delta.</summary>
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoomScript.Properties">
            <summary>Room properties</summary>
        </member>
        <member name="T:KS.Reactor.Secret.BaseDecompressor">
            Base class for all decompressors
        </member>
        <member name="M:KS.Reactor.Secret.BaseDecompressor.DecompressData(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.FrameSectionTypes,System.Int32@,System.Byte[]@)">
             Decompress data compressed by a compressor into a new byte array.
            
             @param   byte[] - buffer data
             @param   int - offset
             @param   int - object size
             @param   FrameSectionTypes frameSectionType
             @param   [out] int - object Count
             @param   [out] byte[] - decoded data
        </member>
        <member name="M:KS.Reactor.Secret.BaseDecompressor.DeserializeFullObjectModel(System.Byte[],System.Int32)">
             Deserialize the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Reactor.Secret.BaseDecompressor.DeserializeUpdateObjectModel(System.Byte[],System.Int32)">
             Deserialize the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Reactor.Secret.BaseFrameSectionDecoder">
            This class defines common constants and interface function required for all frame section decoders.
            Derived classes are responsible for parsing client, entity, controller information for a single
            frame of server data.
        </member>
        <member name="P:KS.Reactor.Secret.BaseFrameSectionDecoder.DecoderEntityTracker">
            Object that tracks decoder entities used by the frame decoder.
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodePlayerController(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and attach player controllers to entities and process input acknowledgements
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeServerEvents(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode and apply server events such as RPCs and connect/disconnects
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeClientProperties(System.Byte[],System.Int32,System.UInt32,System.Boolean,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply client property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   bool is this a full client frame
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeEntityProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply entity property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeOwnerDeltaTimes(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode owner delta times.
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number of owner delta times to decode.
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeSpawnResponses(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            <summary>Decodes responses to spawn entity requests.</summary>
            <param name="data">Source data</param>
            <param name="offset">Data offset</param>
            <param name="encodedObjectCount">Number of responses to decode</param>
            <param name="frameData">Frame data to update</param>
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeRoomProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply room property updates and gravity changes
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingleDelta
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="T:KS.Reactor.Secret.BFDecompressor">
            This class decodes data compressed by BinaryFlagCompressor.
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.SetStaticModelData(System.Byte[])">
            Parse and update the static model data.
            
            @param   byte[] - model data
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.DecompressData(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.FrameSectionTypes,System.Int32@,System.Byte[]@)">
             Decompress data compressed by BinaryFlagCompressor into a new byte array.
            
             @param   byte[] - buffer data
             @param   int - offset
             @param   int - object size
             @param   FrameSectionTypes frameSectionType
             @param   [out] int - object Count
             @param   [out] byte[] - decoded data
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.DeserializeFullObjectModel(System.Byte[],System.Int32)">
             Deserialize the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.DeserializeUpdateObjectModel(System.Byte[],System.Int32)">
             Deserialize the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Reactor.Secret.BinaryFlagFrameSectionDecoder">
            Decodes frame data that was encoded using a binary flag compressor.
        </member>
        <member name="M:KS.Reactor.Secret.BinaryFlagFrameSectionDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BinaryFlagFrameSectionDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingle - if true, decode this update to single delta.
            @param   bool applyDelta
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="T:KS.Reactor.Secret.BitStreamDecoder">
            Decodes frame data that was encoded using a bit stream encoder.
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodePlayerController(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and attach player controllers to entities and process input acknowledgements
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number controllers to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeServerEvents(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode and apply server events such as RPCs and connect/disconnects
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number events to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeClientProperties(System.Byte[],System.Int32,System.UInt32,System.Boolean,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply client property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   bool is this a full client frame
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeEntityProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply entity property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeRoomProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply room property updates and gravity changes
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingleDelta
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeRPC(KS.Reactor.ksBitIStream,System.UInt32@,KS.Reactor.ksMultiType[]@)">
            Decodes an RPC.
            
            @param   ksBitIStream srcData to process.
            @param   out uint rpcId.
            @param   out KSMultiType[] arguments.
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeRPCArguments(KS.Reactor.ksBitIStream)">
            Decodes RPC arguments.
            
            @param   input to decode.
            @return  ksMultiType[] arguments.
        </member>
        <member name="T:KS.Reactor.Secret.DecoderEntity">
            <summary>Holds entity data that is only used on the decoder thread.</summary>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntity.#cctor">
            <summary>Static initialization</summary>
        </member>
        <member name="P:KS.Reactor.Secret.DecoderEntity.Id">
            <summary>Entity id</summary>
        </member>
        <member name="P:KS.Reactor.Secret.DecoderEntity.SyncGroup">
            <summary>Sync group</summary>
        </member>
        <member name="P:KS.Reactor.Secret.DecoderEntity.OwnerId">
            <summary>Id of the player who owns the entity. Zero if there is no owner.</summary>
        </member>
        <member name="P:KS.Reactor.Secret.DecoderEntity.OwnerPermissions">
            <summary>Owner permissions</summary>
        </member>
        <member name="P:KS.Reactor.Secret.DecoderEntity.OwnerOfTransformChangedFrame">
            <summary>The frame on which the transform owner changed.</summary>
        </member>
        <member name="P:KS.Reactor.Secret.DecoderEntity.DecoderState">
            <summary>Holds decoder-specific entity state.</summary>
        </member>
        <member name="P:KS.Reactor.Secret.DecoderEntity.Index">
            <summary>
            The index of this decoder entity in the decoder entity tracker's transform update list. -1 if it is not in
            the list.
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntity.Release">
            <summary>Returns the decoder entity to the pool.</summary>
        </member>
        <member name="T:KS.Reactor.Secret.DecoderEntityTracker">
            <summary>
            Track decoder entities, sync groups and handle their transform updates and removals.
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.GetDecoderEntity(System.UInt32)">
            <summary>Find an existing decoder entity</summary>
            <param name="decoderEntityId">Decoder entity ID</param>
            <returns>Tracked decoder entity.</returns>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.FindOrCreateDecoderEntity(System.UInt32,System.UInt32)">
            <summary>
            Find or create a new decoder entity. 
            If the decoder entity already exists we need to check and update its sync group
            </summary>
            <param name="syncGroupId">Sync group ID</param>
            <param name="decoderEntityId">Decoder entity ID</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.AddSyncGroupDecoderEntity(System.UInt32,System.UInt32)">
            <summary>Add a decoder entity to a tracked sync group.</summary>
            <param name="syncGroupId">Sync group ID</param>
            <param name="decoderEntityId">Decoder entity ID</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.RemoveSyncGroupDecoderEntity(System.UInt32,System.UInt32)">
            <summary>Remove a decoder entity from a tracked sync group.</summary>
            <param name="syncGroupId">Sync group ID</param>
            <param name="decoderEntityId">Decoder entity ID</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.SetOwnerUpdate(System.UInt32)">
            <summary>
            Adds an id to the set of client ids with owned entities we received a client delta time update for.
            </summary>
            <param name="ownerId"></param>
            <returns>False if the id was already in the set.</returns>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.ClearOwnerUpdates">
            <summary>
            Clears the set of client ids with owned entites we received a client delta time update for.
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.AddDecoderEntityTransformUpdate(KS.Reactor.Secret.DecoderEntity)">
            <summary>
            Track a decoder entity that needs to update its transform every frame.
            </summary>
            <param name="decoderEntity">Decoder entity</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.RemoveDecoderEntityTransformUpdate(KS.Reactor.Secret.DecoderEntity)">
            <summary>
            Removes a decoder entity from the list of decoder entities that need transform updates every frame.
            </summary>
            <param name="decoderEntity">Decoder entity to remove</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.UpdateDecoderEntityTransforms(KS.Reactor.Secret.RoomUpdate)">
            <summary>
            Create decoder entity transform updates for all tracked decoder entity transforms.
            </summary>
            <param name="frameData">Room update to add transform updates to.</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.AddDestroyedDecoderEntityId(System.UInt32)">
            <summary>Track a destroyed decoder entity.</summary>
            <param name="decoderEntityId">Decoder entity ID</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.AddRemovedSyncGroupId(System.UInt32)">
            <summary>
            Track the removal of an entire sync group.
            </summary>
            <param name="syncGroupId">Sync group ID</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.AddRemovedDecoderEntityId(System.UInt32,System.UInt32)">
            <summary>
            Track the removal of a decoder entity from a sync group.
            </summary>
            <param name="syncGroupId">Sync group ID</param>
            <param name="decoderEntityId">Decoder entity ID</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.RemoveDecoderEntities(KS.Reactor.Secret.RoomUpdate)">
            <summary>
            Clear the decoder entities tracked in the decoder entity destroy, sync group removals, and decoder entity removal lists.
            </summary>
            <param name="roomUpate">Room update to write sync group entity removals to.</param>
        </member>
        <member name="M:KS.Reactor.Secret.DecoderEntityTracker.RemoveDecoderEntity(System.UInt32)">
            <summary>
            Remove a decoder entity from the decoder entity map and transform update list and returns it to the pool.
            </summary>
            <param name="decoderEntityId">Id of the decoder entity to remove.</param>
        </member>
        <member name="T:KS.Reactor.Secret.Encoder">
            <summary>Encoder for encoding client frame section bodies and authentication data.</summary>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeAuthenticationRPC(KS.Reactor.ksStreamBuffer,KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[])">
            <summary>Encodes an authentication RPC.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="session">Authenticated player session data. Null if the player is not authenticated.</param>
            <param name="authArgs">Authentication arguments</param>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeRoomRPC(KS.Reactor.ksStreamBuffer,System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Encodes a room RPC.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="rpcId">RPC id</param>
            <param name="arguments">RPC arguments</param>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeEntityRPC(KS.Reactor.ksStreamBuffer,System.UInt32,System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Encodes an entity RPC.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="entityId">Id of entity to call RPC on.</param>
            <param name="rpcId">RPC id</param>
            <param name="arguments">RPC arguments</param>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeBatchRPC``1(KS.Reactor.ksStreamBuffer,System.Collections.Generic.IList{``0},System.UInt32,KS.Reactor.ksMultiType[])">
            <summary>Encodes a batch RPC.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="entities">Entities to call RPC on.</param>
            <param name="rpcId">RPC id</param>
            <param name="arguments">RPC arguments</param>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeFullInput(KS.Reactor.ksStreamBuffer,KS.Reactor.ksInputRegistrar,KS.Reactor.ksInput)">
            <summary>Encodes full input data containing registered controller ids and full input state.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="registrar">Input registrar</param>
            <param name="input">Input</param>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeInput(KS.Reactor.ksStreamBuffer,KS.Reactor.ksInputRegistrar,KS.Reactor.ksInput)">
            <summary>Encodes an input update.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="registrar">Input registrar</param>
            <param name="input">Input</param>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeEntityUpdates(KS.Reactor.ksStreamBuffer,System.Collections.Generic.List{KS.Reactor.OwnedEntityUpdate})">
            <summary>Encodes entity updates for updated entities owned by the local player.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="updates">Entity updates to encode.</param>
        </member>
        <member name="M:KS.Reactor.Secret.Encoder.EncodeEntitySpawn(KS.Reactor.ksStreamBuffer,KS.Reactor.ksEntityId,KS.Reactor.ksSpawnParams,KS.Reactor.ksMultiType[])">
            <summary>Encodes an entity spawn request.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="spawnId">Temporary spawn id</param>
            <param name="spawnParams">Spawn parameters</param>
            <param name="args">Additional spawn arguments</param>
        </member>
        <member name="T:KS.Reactor.Secret.EntityArrayManager">
            This class manages the entity indices. We send entity data in order to avoid sending entity ids.
            The EntityArrayManager will generate an index for a new entity and record it so we can get the entity id
            for an entity when its udpate data is decoded.
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.GetNextIndex">
            Gets the next available index.
            
            @return  int
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.ReserveIndex">
            Reserve the next highest encoding index for reuse in a later frame.
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.AddEntityId(System.UInt32)">
            Puts the given entity id at the next available index.
            
            @param   uint entity id
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.GetEntityId(System.Int32)">
            Gets the entity id at the given index.
            
            @param   int index
            @return  uint entity id - 0 means there is no entity at the given index
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.RecoverIndexForEntity(System.UInt32)">
            Recovers the index of the given entity. Removes this entity id from the entity array.
            Adds this entity's index to the list of indices that we can assign to a new entity.
            
            @param   uint entityId
            @return  bool return true if the entity was found and the index was recovered
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.RecoverIndex(System.Int32)">
            Recovers the given index. Adds this index to the list of indices that we can assign to a new entity.
            
            @param   int index
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.RecycleIndices">
            Move recovered indices into the available indices list and sort it.
        </member>
        <member name="T:KS.Reactor.Secret.EntityUpdate">
            <summary>
            Tracks updates for an entity. Using the setters for a property will set the corresponding
            <see cref="T:KS.Reactor.Secret.EntityUpdate.UpdateFlags"/> for that property. Entity updates are pooled. Returning an entity update to the pool
            using <see cref="M:KS.Reactor.Secret.EntityUpdate.Release"/> will clear the <see cref="P:KS.Reactor.Secret.EntityUpdate.Flags"/> and the <see cref="P:KS.Reactor.Secret.EntityUpdate.Properties"/>, but will not
            clear any other values.
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.EntityUpdate.#cctor">
            <summary>Static initialization</summary>
        </member>
        <member name="T:KS.Reactor.Secret.EntityUpdate.UpdateFlags">
            <summary>Update flags</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.NEW">
            <summary>
            The entity is new or changed sync groups. This is set when <see cref="P:KS.Reactor.Secret.EntityUpdate.AssetId"/> is set.
            </summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.POSITION">
            <summary>Position updated</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.ROTATION">
            <summary>Rotation updated</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.SCALE">
            <summary>Scale updated</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.TELEPORT">
            <summary>The entity teleported</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.PROPERTIES">
            <summary>The entity has changed properties</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.OWNER">
            <summary>The owner changed</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.PERMISSIONS">
            <summary>Owner permissions changed</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.CONTROLLER_TYPE">
            <summary>The player controller changed and the player controller is identified by type id.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.CONTROLLER_ASSET_ID">
            <summary>The player controller changed and the player controller is identified by asset id.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.SYNC_GROUP">
            <summary>The sync group changed.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.REMOVE_SYNC_GROUP">
            <summary>The entity was removed from its sync group into a sync group that is not synced.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.SPAWN_ID">
            <summary>The entity was spawned by the local player and has a spawn id.</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.EntityId">
            <summary>Entity id</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.AssetId">
            <summary>Asset id. Identifies the entity prefab.</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.SpawnId">
            <summary>Spawn id</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.Position">
            <summary>Position</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.Rotation">
            <summary>Rotation</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.Scale">
            <summary>Scale</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.Properties">
            <summary>Changed properties</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.OwnerId">
            <summary>Owner id</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.OwnerPermissions">
            <summary>Owner permissions</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.ControllerId">
            <summary>
            Controller id. If <see cref="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.CONTROLLER_TYPE"/> is set, this is a controller type id. If
            <see cref="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.CONTROLLER_ASSET_ID"/> is set, it is an asset id.
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.EntityUpdate.SetController(System.UInt32,System.Boolean)">
            <summary>
            Sets the <see cref="P:KS.Reactor.Secret.EntityUpdate.ControllerId"/> and an update flag to indicate the controller changed.
            </summary>
            <param name="controllerId">
            Controller id. If <paramref name="isAsset"/> is true, this is an asset id, otherwise it is a controller
            type id.
            </param>
            <param name="isAsset">
            If true, sets <see cref="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.CONTROLLER_ASSET_ID"/>, otherwise sets
            <see cref="F:KS.Reactor.Secret.EntityUpdate.UpdateFlags.CONTROLLER_TYPE"/>.
            </param>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.SyncGroup">
            <summary>The sync group the entity belongs to.</summary>
        </member>
        <member name="P:KS.Reactor.Secret.EntityUpdate.Flags">
            <summary>Flags indicating which updates the entity has.</summary>
        </member>
        <member name="M:KS.Reactor.Secret.EntityUpdate.HasUpdate(KS.Reactor.Secret.EntityUpdate.UpdateFlags)">
            <summary>Checks if update flags are set.</summary>
            <param name="flags">Flags to check for.</param>
            <returns>True if any of the <paramref name="flags"/> are set.</returns>
        </member>
        <member name="M:KS.Reactor.Secret.EntityUpdate.Release">
            <summary>
            Clears the <see cref="P:KS.Reactor.Secret.EntityUpdate.Flags"/> and <see cref="P:KS.Reactor.Secret.EntityUpdate.Properties"/> and returns the object to the pool.
            </summary>
        </member>
        <member name="T:KS.Reactor.Secret.FixedLengthDecoder">
            Decodes frame data that was encoded using a fixed length compressor.
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodePlayerController(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and attach player controllers to entities and process input acknowledgements
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeServerEvents(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode and apply server events such as RPCs and connect/disconnects
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeClientProperties(System.Byte[],System.Int32,System.UInt32,System.Boolean,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply client property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   bool activate existing clients
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeEntityProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply entity property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeRoomProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply room property updates and gravity changes
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.ApplyFixedPointObject(KS.Reactor.Secret.RoomUpdate,KS.Reactor.Secret.FixedPointObject@,System.UInt32)">
            Apply the given fixed point object to its entity update. Create a new decoder entity and entity update if
            none was found.
            
            @param   RoomUpdate frame Data
            @param   FixedPointObject fpEntity
            @param   uint Sync group
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingle - if true, decode this update to single delta.
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.ApplyFixedPointTransform(KS.Reactor.Secret.RoomUpdate,KS.Reactor.Secret.FixedPointTransform,System.Boolean,System.UInt32)">
            Apply the given fixed point transform to its entity update.
            
            @param   RoomUpdate frame Data
            @param   FixedPointTransform fpTransform
            @param   bool isSingle - if true, assign single delta. Otherwise, apply double delta onto the single delta.
            @param   bool applyDelta
            @param   uint Sync group
        </member>
        <member name="T:KS.Reactor.Secret.FLCompressor">
            Compresses unordered arrays of fixed-length data.
        </member>
        <member name="M:KS.Reactor.Secret.FLCompressor.Compress``1(``0[])">
            Compresses an ordered array of structs.
            
            @param   T[] values to compress.
            @return  byte[] compressed data.
        </member>
        <member name="M:KS.Reactor.Secret.FLCompressor.CompressData(System.Byte[],System.Int32,System.Int32)">
            Compresses a byte array of unordered fixed-length objects.
            
            @param   byte[] data to compress.
            @param   int objectSize
            @param   int objectCount
            @return  byte[] compressed data.
        </member>
        <member name="T:KS.Reactor.Secret.FLDecoderEntityState">
            Entity state for FLCompressor. It stores last transform data and deltas in int arrays and the precisions.
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.Position">
            Position
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.Rotation">
            Rotation
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.Scale">
            Scale
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.DeltaPosition">
            DeltaPosition
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.DeltaRotation">
            DeltaRotation
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.DeltaScale">
            DeltaScale
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.HasReceivedUpdates">
            The decoder state will have non-null delta positions, rotations, or scales if we have received an update.
            
            @return bool
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.PositionPrecision">
            Position Precision
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.RotationPrecision">
            Rotation Precision
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.ScalePrecision">
            Scale Precision
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.HasPositionDelta">
            Is there a non-zero position delta?
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.HasRotationDelta">
            Is there a non-zero rotation delta?
        </member>
        <member name="P:KS.Reactor.Secret.FLDecoderEntityState.HasScaleDelta">
            Is there a non-zero scale delta?
        </member>
        <member name="M:KS.Reactor.Secret.FLDecoderEntityState.FirstThreeAreZeros(System.Int32[])">
            Returns true if first three elements in the given array are zeros.
            
            @param   int[] array to check
            @return  bool
        </member>
        <member name="M:KS.Reactor.Secret.FLDecoderEntityState.Update(KS.Reactor.Secret.RoomUpdate,KS.Reactor.Secret.DecoderEntity)">
            Applies deltas and stores an update for a sync object in the room update. Called after decoding a server
            frame if the sync object is in the list of objects with decoder states needing updates.
            
            @param   RoomUpdate frameData
            @param   DecoderEntity decoderEntity
            @return  bool true if this should be called again after decoding the next server frame. False to remove the
                     sync object from the list with decoder states needing updates.
        </member>
        <member name="T:KS.Reactor.Secret.FLDecompressor`1">
            This class decodes data compressed by FLCompressor. 
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.SetStaticModelData(System.Byte[])">
            Parse and update the static model data.
            
            @param   byte[] - mode data buffer
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.Decompress``1(System.Byte[],System.Int32)">
            Decompresses data from a byte array into an unordered array of structs.
            
            @param   byte[] data to decode.
            @param   int offset to begin decoding at.
            @return  T[] decoded struct array.
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.DecompressData(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.FrameSectionTypes,System.Int32@,System.Byte[]@)">
             Decompress stream data from a byte array into a new byte array.
             
             Case: Full/Partial frame + model => decode using the provided model then discard it.
             Case: Full/Partial frame + no model => decode using the static model
             Case: Update frame + model => decode using the provided model then store it.
             Case: Update frame + no model + model delta => apply delta to the model, decode the frame, then reconstruct a new update model
             Case: Update frame + no model + no delta => decode using the current update model
            
             @param   byte[] - buffer data
             @param   int - offset
             @param   int - object size
             @param   FrameSectionTypes frameSectionType
             @param   [out] int - object Count
             @param   [out] byte[] - decoded data
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.DeserializeFullObjectModel(System.Byte[],System.Int32)">
             Decode the full object model.
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.DeserializeUpdateObjectModel(System.Byte[],System.Int32)">
             Decode the update object model.
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FLDecompressor`1.DecompressData(KS.Reactor.ksBitIStream,System.Int32,System.Byte[]@,System.Int32@)" -->
        <member name="T:KS.Reactor.Secret.FPObjectDecoder">
            This class is used to decode full object data compressed by FLCompressor.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPObjectDecoder.DecodeFullObject(KS.Reactor.ksBitIStream,System.Collections.Generic.List{KS.Reactor.Secret.FixedPointObject}@,System.Single@)" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPObjectDecoder.GetOutputObjects(System.Byte[],System.Int32)" -->
        <member name="T:KS.Reactor.Secret.FPTransformDecoder">
            This class is used to decode delta transform data compressed by FLCompressor.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPTransformDecoder.DecodeTransform(KS.Reactor.ksBitIStream,System.Collections.Generic.List{KS.Reactor.Secret.FixedPointTransform}@)" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPTransformDecoder.GetOutputTransforms(System.Byte[],System.Int32)" -->
        <member name="T:KS.Reactor.Secret.FrameDecoder">
            Decode a server frame and subsequently extracting and decoding frame sections data.
        </member>
        <member name="T:KS.Reactor.Secret.FrameDecoder.Config">
            Configuration settings for decoding frame data.
        </member>
        <member name="P:KS.Reactor.Secret.FrameDecoder.DecodeFrameSections">
            If false, frame section data is not decoded.
        </member>
        <member name="P:KS.Reactor.Secret.FrameDecoder.SyncRate">
            Number of frames synced per server update
        </member>
        <member name="P:KS.Reactor.Secret.FrameDecoder.SimulationRate">
            Unscale amount of time in microseconds that the server simulates per frame.
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.#ctor(KS.Reactor.Secret.FrameDecoder.Config)">
            Constructor
            
            @param   Config - configuration settings
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.CreateDecoder(KS.Reactor.Secret.EncoderTypes)">
            Construct a base frame section decoder for an encoding type
            
            @param   EncoderTypes
            @return  BaseFrameSectionDecoder
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.SetStaticModelData(System.Byte[])">
            Set new static model used by the decompressor
            
            @param   byte[] - mode data buffer
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.DecodeFrame(KS.Reactor.ksStreamBuffer,KS.Reactor.Client.ksBaseRoom)">
            Read the frame and parse out frame section headers and data
            
            @param   ksStreamBuffer - buffer containing a frame packet header and body
            @param   ksBaseRoom room
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.DecodeFrameSectionHeader(System.Byte[],System.Int32@,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.BaseDecompressor,KS.Reactor.Secret.EntityArrayManager)">
            Decode the frame section header and data
            
            @param   byte[] encoded data
            @param   int data offset
            @param   uint length of encoded data
            @param   RoomUpdate frame data
        </member>
        <member name="T:KS.Reactor.Secret.FrameSectionTypes">
            Frame Section Types
        </member>
        <member name="T:KS.Reactor.Secret.ClientFrameSectionTypes">
            Client Frame Section Types
        </member>
        <member name="T:KS.Reactor.Secret.EncoderTypes">
            Frame Section Types
        </member>
        <member name="T:KS.Reactor.Secret.CompressorTypes">
            Frame Section Types
        </member>
        <member name="T:KS.Reactor.Secret.SyncGroupHeader">
            Sync group header structure
        </member>
        <member name="M:KS.Reactor.Secret.SyncGroupHeader.ToString">
            Return a string summarizing this object.
            
            @return string
        </member>
        <member name="M:KS.Reactor.Secret.SyncGroupHeader.Deserialize(System.Byte[],System.Int32@)">
            Read header data from a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="M:KS.Reactor.Secret.SyncGroupHeader.Serialize(System.Byte[],System.Int32@)">
            Write header data to a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="T:KS.Reactor.Secret.SectionHeader">
            Section header structure
        </member>
        <member name="M:KS.Reactor.Secret.SectionHeader.ToString">
            Return a string summarizing this object.
            
            @return string
        </member>
        <member name="M:KS.Reactor.Secret.SectionHeader.Deserialize(System.Byte[],System.Int32@)">
            Read header data from a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="M:KS.Reactor.Secret.SectionHeader.Serialize(System.Byte[],System.Int32@)">
            Write header data to a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="T:KS.Reactor.Secret.IDecoderEntityState">
            Interface for decoder entity state. Each sync object has a reference to this interface which can be set to a
            decoder-specific implementation to store entity state specific to that decoder.
        </member>
        <member name="M:KS.Reactor.Secret.IDecoderEntityState.Update(KS.Reactor.Secret.RoomUpdate,KS.Reactor.Secret.DecoderEntity)">
            Applies an update to the sync object. Called after decoding a server frame if the sync object is in the
            list of objects with decoder states needing updates.
            
            @param   RoomUpdate frameData
            @param   DecoderEntity decoderEntity
            @return  bool true if this should be called again after decoding the next server frame. False to remove the
                     sync object from the list with decoder states needing updates.
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.#ctor(System.Int32)">
            <summary>
            Construct a buffer and set its capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.#ctor(System.Byte[])">
            <summary>
            Construct a buffer which holds a copy of a byte array.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Allocate(System.Int32,System.Boolean)">
            <summary>
            Fetch a buffer from the pool or create a new buffer and set its capacity.
            </summary>
            <param name="capacity"></param>
            <param name="fromPool"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Allocate(System.Byte[],System.Boolean)">
            <summary>
            Fetch a buffer from the pool or create a new buffer which holds a copy of a byte array.
            </summary>
            <param name="bytes"></param>
            <param name="fromPool"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.FixLength(System.Int32)">
            <summary>
            Get the nearest power of 2 larger that the input value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Flip(System.Byte[])">
            <summary>
            翻转字节数组，如果本地字节序列为高字节序列，则进行翻转以转换为低字节序列
            </summary>
            <param name="bytes">待转为高字节序的字节数组</param>
            <returns>低字节序列的字节数组</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.FixSizeAndReset(System.Int32,System.Int32)">
            <summary>
            Compare two lengths and resize the byte buffer to accomodate the future length.
            </summary>
            <param name="currLen"></param>
            <param name="futureLen"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.EnsureWritableBytes(System.Int32)">
            <summary>
            Adjust the buffer to accomodate <paramref name="minBytes"/> new bytes of data.
            </summary>
            <param name="minBytes"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write bytes into the buffer.
            </summary>
            <param name="bytes">Source array</param>
            <param name="index">Index in the buffer to start copying from.</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteBytes(System.Byte[],System.Int32)">
            <summary>
            Write bytes into the buffer.
            </summary>
            <param name="bytes">Source array</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteBytes(System.Byte[])">
            <summary>
            Write bytes into the buffer.
            </summary>
            <param name="bytes">Source array</param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Write(KS.Reactor.Secret.KCPBuffer)">
            <summary>
            Copy bytes from a <see cref="T:KS.Reactor.Secret.KCPBuffer"/>buffer.
            </summary>
            <param name="buffer">Source buffer</param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteShort(System.Int16)">
            <summary>
            Write a <see cref="T:System.Int16"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteUshort(System.UInt16)">
            <summary>
            Write a <see cref="T:System.UInt16"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteInt(System.Int32)">
            <summary>
            Write a <see cref="T:System.Int32"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteUint(System.UInt32)">
            <summary>
            Write a <see cref="T:System.UInt32"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteLong(System.Int64)">
            <summary>
            Write a <see cref="T:System.Int64"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteUlong(System.UInt64)">
            <summary>
            Write a <see cref="T:System.UInt64"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteFloat(System.Single)">
            <summary>
            Write a <see cref="T:System.Single"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteByte(System.Byte)">
            <summary>
            Write a <see cref="T:System.Byte"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteByte(System.Int32)">
            <summary>
            Write the lowest byte of an  <see cref="T:System.Int32"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteDouble(System.Double)">
            <summary>
            Write a <see cref="T:System.Double"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteChar(System.Char)">
            <summary>
            Write a <see cref="T:System.Char"/> into the buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteBoolean(System.Boolean)">
            <summary>
            写入一个布尔型数据
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadByte">
            <summary>
            读取一个字节
            </summary>
            <returns>字节数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Get(System.Int32,System.Int32)">
            <summary>
            获取从index索引处开始len长度的字节
            </summary>
            <param name="index"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Read(System.Int32)">
            <summary>
            从读取索引位置开始读取len长度的字节数组
            </summary>
            <param name="len">待读取的字节长度</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadUshort">
            <summary>
            读取一个uint16数据
            </summary>
            <returns>ushort数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadShort">
            <summary>
            读取一个int16数据
            </summary>
            <returns>short数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadUint">
            <summary>
            读取一个uint32数据
            </summary>
            <returns>uint数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadInt">
            <summary>
            读取一个int32数据
            </summary>
            <returns>int数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadUlong">
            <summary>
            读取一个uint64数据
            </summary>
            <returns>ulong数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadLong">
            <summary>
            读取一个long数据
            </summary>
            <returns>long数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadFloat">
            <summary>
            读取一个float数据
            </summary>
            <returns>float数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadDouble">
            <summary>
            读取一个double数据
            </summary>
            <returns>double数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadChar">
            <summary>
            读取一个字符
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadBoolean">
            <summary>
            读取布尔型数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从读取索引位置开始读取len长度的字节到disbytes目标字节数组中
            </summary>
            <param name="disbytes">读取的字节将存入此字节数组</param>
            <param name="disstart">目标字节数组的写入索引</param>
            <param name="len">读取的长度</param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetByte(System.Int32)">
            <summary>
            获取一个字节
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetByte">
            <summary>
            获取一个字节
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetDouble(System.Int32)">
            <summary>
            获取一个双精度浮点数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetDouble">
            <summary>
            获取一个双精度浮点数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetFloat(System.Int32)">
            <summary>
            获取一个浮点数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetFloat">
            <summary>
            获取一个浮点数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetLong(System.Int32)">
            <summary>
            获取一个长整形数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetLong">
            <summary>
            获取一个长整形数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetUlong(System.Int32)">
            <summary>
            获取一个长整形数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetUlong">
            <summary>
            获取一个长整形数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetInt(System.Int32)">
            <summary>
            获取一个整形数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetInt">
            <summary>
            获取一个整形数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetUint(System.Int32)">
            <summary>
            获取一个整形数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetUint">
            <summary>
            获取一个整形数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetShort(System.Int32)">
            <summary>
            获取一个短整形数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetShort">
            <summary>
            获取一个短整形数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetUshort(System.Int32)">
            <summary>
            获取一个短整形数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetUshort">
            <summary>
            获取一个短整形数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetChar(System.Int32)">
            <summary>
            获取一个char数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetChar">
            <summary>
            获取一个char数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetBoolean(System.Int32)">
            <summary>
            获取一个布尔数据，不改变数据内容
            </summary>
            <param name="index">字节索引</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.GetBoolean">
            <summary>
            获取一个布尔数据，不改变数据内容
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.DiscardReadBytes">
            <summary>
            清除已读字节并重建缓存区
            </summary>
        </member>
        <member name="P:KS.Reactor.Secret.KCPBuffer.ReaderIndex">
            <summary>
            设置/获取读指针位置
            </summary>
        </member>
        <member name="P:KS.Reactor.Secret.KCPBuffer.WriterIndex">
            <summary>
            设置/获取写指针位置
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.MarkReaderIndex">
            <summary>
            标记读取的索引位置
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.MarkWriterIndex">
            <summary>
            标记写入的索引位置
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ResetReaderIndex">
            <summary>
            将读取的索引位置重置为标记的读取索引位置
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ResetWriterIndex">
            <summary>
            将写入的索引位置重置为标记的写入索引位置
            </summary>
        </member>
        <member name="P:KS.Reactor.Secret.KCPBuffer.ReadableBytes">
            <summary>
            可读的有效字节数
            </summary>
            <returns>可读的字节数</returns>
        </member>
        <member name="P:KS.Reactor.Secret.KCPBuffer.WritableBytes">
            <summary>
            可写的剩余空间数
            </summary>
            <returns>可写的字节数</returns>
        </member>
        <member name="P:KS.Reactor.Secret.KCPBuffer.Capacity">
            <summary>
            获取缓存区容量大小
            </summary>
            <returns>缓存区容量</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ToArray">
            <summary>
            获取可读的字节数组
            </summary>
            <returns>字节数据</returns>
        </member>
        <member name="T:KS.Reactor.Secret.KCPBuffer.DataType">
            <summary>
            简单的数据类型
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteValue(System.Int32,KS.Reactor.Secret.KCPBuffer.DataType)">
            <summary>
            写入一个数据
            </summary>
            <param name="value">待写入的数据</param>
            <param name="type">待写入的数据类型</param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadValue(KS.Reactor.Secret.KCPBuffer.DataType)">
            <summary>
            读取一个值，值类型根据type决定，int或short或byte
            </summary>
            <param name="type">值类型</param>
            <returns>int数据</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteUTF8String(System.String,KS.Reactor.Secret.KCPBuffer.DataType)">
            <summary>
            写入一个UTF-8字符串，UTF-8字符串无高低字节序问题
            <para>写入缓冲区的结构为字符串字节长度（类型由lenType指定） + 字符串字节数组</para>
            </summary>
            <param name="content">待写入的字符串</param>
            <param name="lenType">写入的字符串长度类型</param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.WriteUTF(System.String)">
            <summary>
            写入以short表示的字符串字节长度和字符串字节数据
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadUTF8String(System.Int32)">
            <summary>
            读取一个UTF-8字符串，UTF-8字符串无高低字节序问题
            </summary>
            <param name="len">需读取的字符串长度</param>
            <returns>字符串</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadUTF8String(KS.Reactor.Secret.KCPBuffer.DataType)">
            <summary>
            读取一个UTF-8字符串，UTF-8字符串无高低字节序问题
            </summary>
            <param name="lenType">字符串长度类型</param>
            <returns>字符串</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ReadUTF">
            <summary>
            读取short类型的字符串字节长度，然后根据此长度读取对应数量的字节数据后转为字符串
            </summary>
            <returns>UTF-8字符串</returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Copy">
            <summary>
            复制一个对象，具有与原对象相同的数据，不改变原对象的数据，不包括已读数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Clone">
            <summary>
            深度复制，具有与原对象相同的数据，不改变原对象的数据，包括已读数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.ForEach(System.Action{System.Byte})">
            <summary>
            遍历所有的字节数据
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Clear">
            <summary>
            清空此对象，但保留字节缓存数组（空数组）
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.KCPBuffer.Dispose">
            <summary>
            释放对象，清除字节缓存数组，如果此对象为可池化，那么调用此方法将会把此对象推入到池中等待下次调用
            </summary>
        </member>
        <member name="T:KS.Reactor.Secret.PacketDecoder">
            Handles the decoding of packet data from stream buffers.
        </member>
        <member name="T:KS.Reactor.Secret.PacketDecoder.AuthenticationResult">
            Authentication response packet data
        </member>
        <member name="T:KS.Reactor.Secret.PacketDecoder.PingResult">
            Ping response packet data
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodeFrameDecoderConfigs(KS.Reactor.ksStreamBuffer)">
            Decode frame decoder configs from a streambuffer
            
            @param   ksStreamBuffer - buffer
            @return  FrameDecoder.Config
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodeStaticModelData(KS.Reactor.ksStreamBuffer)">
            Decode static model data from a streambuffer
            
            @param   ksStreamBuffer - buffer
            @return  byte[]
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodeAuthenticationResponse(KS.Reactor.ksStreamBuffer)">
            Decode an authentication result from a stream buffer. 
            If the authentication succeeded, the result will contain the local player ID.
            If the authentication failed, the result will contain a connect status value and a custom status value.
            
            @param   ksStreamBuffer - buffer
            @return  AuthenticationResult
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodePong(KS.Reactor.ksStreamBuffer)">
            Decode a ping response (pong) from a stream buffer.
            Pong messages contain a type and the tick count of when the ping was sent.
            
            @param   ksStreamBuffer - buffer
            @return  PingResult
        </member>
        <member name="T:KS.Reactor.Secret.PacketEncoder">
            Handles the encoding of data and the writing of packet headers and bodies to stream buffers.
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.GetVersion">
            Get the version information for this encoder.
            
            @return  VersionInfo
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeRouting(System.UInt32,KS.Reactor.ksStreamBuffer)">
            Write a routing packet to a stream buffer.
            
            @param   uint - roomId
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeValidateModel(System.Byte[],KS.Reactor.ksStreamBuffer)">
            Write a model validation packet to a stream buffer.
            
            @param   byte[] - Checksum data for the current frame decoder model.
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeAuthentication(KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)">
            Write an authentication packet to a stream buffer.
            
            @param   ksPlayerAPI.Session - Player session
            @param   ksMultiType[] - Authentication arguments
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.StartEncodeClientFrameData(KS.Reactor.ksStreamBuffer)">
            Write the client frame data header
            
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EndEncodeClientFrameData(KS.Reactor.ksStreamBuffer)">
            Complete the client frame data header by updating the data length.
            
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeClientTiming(System.UInt64,System.UInt64,System.Single,KS.Reactor.ksStreamBuffer)">
            Write the client time and last processed frame number
            
            @param   ulong - Client time
            @param   ulong - Last processed frame number
            @param   float deltaTime since the last sent frame.
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeRoomRPC(System.UInt32,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)">
            Write a room rpc packet to a stream buffer.
            
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeEntityRPC(System.UInt32,System.UInt32,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)">
            Write an entity rpc packet to a stream buffer.
            
            @param   uint - Entity ID
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
            @param   ksStreamBuffer - buffer
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.PacketEncoder.EncodeBatchRPC``1(System.Collections.Generic.IList{``0},System.UInt32,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)" -->
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeFullInput(KS.Reactor.ksInputRegistrar,KS.Reactor.ksInput,KS.Reactor.ksStreamBuffer)">
            Write a full input packet to a stream buffer.
            
            @param   ksInputRegistrar - Input registrar
            @param   ksInput - Input state
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeInput(KS.Reactor.ksInputRegistrar,KS.Reactor.ksInput,KS.Reactor.ksStreamBuffer)">
            Write an input packet to a stream buffer.
            
            @param   ksInputRegistrar - Input registrar
            @param   ksInput - Input state
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodePing(KS.Reactor.ksStreamBuffer,System.Boolean)">
            Write a ping packet to a stream buffer.
            
            @param   ksStreamBuffer - buffer
            @param   bool - True if this is an RPC ping.
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeIdle(KS.Reactor.ksStreamBuffer,System.Boolean)">
            Write a idle packet to a stream buffer.
            
            @param   ksStreamBuffer - buffer
            @param   bool idle value to encode.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.PacketEncoder.EncodeEntityUpdates(KS.Reactor.ksStreamBuffer,System.Collections.Generic.List{KS.Reactor.OwnedEntityUpdate})" -->
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeEntitySpawn(KS.Reactor.ksStreamBuffer,KS.Reactor.ksEntityId,KS.Reactor.ksSpawnParams,KS.Reactor.ksMultiType[])">
            <summary>Encodes an entity spawn request.</summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="spawnId">Temporary spawn id</param>
            <param name="spawnParams">Spawn parameters</param>
            <param name="args">Additional spawn arguments</param>
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.BeginFrameSection(KS.Reactor.ksStreamBuffer,KS.Reactor.Secret.ClientFrameSectionTypes)">
            <summary>
            Encodes a frame section header. Reserves space for the length to be written the frame section body is written.
            </summary>
            <param name="buffer">Buffer to write to.</param>
            <param name="type">Frame section type</param>
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EndFrameSection(KS.Reactor.ksStreamBuffer)">
            <summary>
            Writes the length of the frame section body to the frame section header. The length is calculated as the 
            difference between the current write offset and the end of the current frame section header.
            </summary>
            <param name="buffer">Buffer to write to.</param>
        </member>
        <member name="T:KS.Reactor.Secret.PacketHeader">
            Structure that contains data and enums for the Reactor packet protocol.
        </member>
        <member name="T:KS.Reactor.Secret.PacketIO">
            Reads and writes Reactor packets to a connection object. Manages routing of read packets to appropriate packet handlers.
        </member>
        <member name="T:KS.Reactor.Secret.PacketIO.WriteHandler">
            Handler to be invoked when a packet is written to a connection.
            
            @param   ksConnection - Connection that was written to.
            @param   ksStreamBuffer - Buffer that will be written to the connection.
            @param   SocketError - Write errors
        </member>
        <member name="T:KS.Reactor.Secret.PacketIO.ReadHandler">
            Handler to be invoked when a packet (header+body) is read from a connection.
            
            @param   ksConnection - Connection that was read from.
            @param   ksStreamBuffer - Buffer containing the packet header and body.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.WriteOperation.#ctor(KS.Reactor.ksStreamBuffer,KS.Reactor.Secret.PacketIO.WriteHandler)">
            Constructor.
            
            @param   ksStreamBuffer - Stream buffer operated on.
            @param   WriteHandler - Callback to invoke when the write operation completes.
        </member>
        <member name="P:KS.Reactor.Secret.PacketIO.IsReading">
            Return true if the packet reader is actively reading from a connection.
            
            @return  bool
        </member>
        <member name="P:KS.Reactor.Secret.PacketIO.Connection">
            Bound connection
            
            @return  ksConnection
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.#ctor(KS.Reactor.Client.ksConnection)">
            Constructor.
            
            @param   ksConnection - Connection that the packet reader will operate on.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.AddHandler(KS.Reactor.Secret.PacketHeader.Types,KS.Reactor.Secret.PacketIO.ReadHandler)">
            Add a handler for a type of packet
            
            @param   PacketHeader.Types - Packet type
            @param   ReadHandler - Callback to invoke when the specified packet is read from a connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.RemoveHandler(KS.Reactor.Secret.PacketHeader.Types)">
            Remove a handler for a type of packet
            
            @param   PacketHeader.Types - Packet type
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.BeginRead">
            Begin reading packets from the connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.StopRead">
            Stop reading packets from the connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.ReadNext">
            Read the next packet from the connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.Write(KS.Reactor.ksStreamBuffer,KS.Reactor.Secret.PacketIO.WriteHandler)">
            Write buffer data containing packet data to the bound connection.
            
            @param   ksStreamBuffer - Buffer containing a packet header and body.
            @param   WriteHandler - Callback to invoke once the write completes.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.HandleReceiveHeader(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer.Segment,System.Net.Sockets.SocketError,System.Object)">
            Handle recevied packet headers.
            Check the header for the amount of body data expected and begin a new read operation for that data.
            If the body length is 0, then pass the data to the body handler.
            
            @param   ksConnection - Connection that was read from.
            @param   ksStreamBuffer.Segment - Buffer segment that contains the header data.
            @param   SocketError - Read error.
            @param   object - Async state object.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.HandleReceiveBody(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer.Segment,System.Net.Sockets.SocketError,System.Object)">
             Handle recevied packet body.
             Read the header data and look for an appropriate packet handler. 
            
             @param   ksConnection - Connection that was read from.
             @param   ksStreamBuffer.Segment - Buffer segment that contains the header data.
             @param   SocketError - Read error.
             @param   object - Async state object.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.HandleSend(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer.Segment,System.Net.Sockets.SocketError,System.Object)">
             Handle the completion of a write operation to a connection.
            
             @param   ksConnection - Connection that was read from.
             @param   ksStreamBuffer.Segment - Buffer segment that contains the header data.
             @param   SocketError - Read error.
             @param   object - Async state object.
        </member>
        <member name="T:KS.Reactor.Secret.QuantizationUtility">
            This class contains utility methods for quantization and dequantization.
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.IntArrayToVector3(System.Int32[],System.Single)">
            Dequantize int array to a ksVector3.
            
            @param   int[] array
            @param   float precision
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.DecodeQuaternion(System.Int32[],System.Int32)">
            Decode a quaternion from quantized smallest three and the index of the biggest element.
            
            @param   int[] qInt - smallest three of the quaternion
            @param   int maxValue - max possible value
            @return  ksQuaternion
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.DecodeQuaternion(System.Int32[],KS.Reactor.ksQuaternion@,System.Int32)">
            Decode a quaternion from quantized smallest three and the index of the biggest element.
            
            @param   int[] qInt - smallest three of the quaternion and the index of the biggest element
            @param   out ksQuaternion q - smallest three of the quaternion
            @param   int maxValue - max possible value
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ReinterpretQuaternion(System.UInt32,System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Converts the x, y, z values to a quaternion using bit-reinterpretation. <paramref name="qMax"/> is the index
            of the largest component value which gets calculated from the other components.
            </summary>
            <param name="x">X value</param>
            <param name="y">Y value</param>
            <param name="z">Z value</param>
            <param name="qMax">
            Index of the largest component value that gets computed from the other components. Eg. if this is 2,
            the resulting quaternion will be (x, y, m, z) where m is the max component value calculated from the other
            components.
            </param>
            <returns>Reinterpreted quaternion</returns>
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.IntArrayToQuaternion(System.Int32[],System.Single)">
            <summary>
            Decodes a quaternion from quantized smallest three and the index of the largest value.
            </summary>
            <param name="array">
            The first three elements are the smallest three values, and the fourth is the index of the largest value.
            </param>
            <param name="precision">Quantization precision</param>
            <returns>Decoded quaternion</returns>
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ToIntArray(System.UInt32,System.UInt32,System.UInt32,System.Boolean,System.Boolean,System.Boolean,System.Int32[])">
            Form an int array from uints and their signs.
            
            @param   uint X
            @param   uint Y
            @param   uint Z
            @param   bool negX
            @param   bool negY
            @param   bool negZ
            @param   int[] intArray
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ReinterpretVector(System.UInt32,System.UInt32,System.UInt32)">
            Convert the uint x, y, z values into floats via bit reinterpretation
            
            @param   uint X value
            @param   uint Y value
            @param   uint Z value
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ReinterpretVector(System.Int32[])">
            Reinterpret an int array's first three values to floats then put them in a ksVector3 and return.
            
            @param   int[] int array
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ReinterpretToIntArray(System.UInt32,System.UInt32,System.UInt32,System.Int32[])">
            Reinterpret three uints to ints and put them in the given int array.
            
            @param   uint X value
            @param   uint Y value
            @param   uint Z value
            @param   int[] int array
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.IntAddition(System.Int32[],System.Int32[],System.Single)">
            Apply delta array on to last value array and convert the result to a ksVector3.
            
            @param   int[] last
            @param   int[] delta
            @param   float precision
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ApplyDelta(System.Int32[],System.Int32[])">
            Apply delta.
            
            @param   int[] last
            @param   int[] delta
        </member>
        <member name="T:KS.Reactor.Secret.RoomUpdate">
            RoomUpdate stores decoded frame data and applies updates during the ksBaseRoom update
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.Room">
            Room.
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.Frame">
            Frame number.
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.ServerTime">
            Total amount of time simulated on the server.
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.ServerDeltaTime">
            Amount of time simulated on the server since the last frame.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.#ctor(KS.Reactor.Client.ksBaseRoom)">
            Constructor 
            
            @param   ksBaseRoom
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddInputAck(System.Int32)">
            Store input acknowledgements for this frame
            
            @param   int input acknowledgements
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.FindOrCreateEntityUpdate(System.UInt32)">
            <summary>Gets the entity update for the entity with the given id, or creates one if none exists.</summary>
            <param name="entityId">Id of entity to get update for.</param>
            <returns>Entity update</returns>
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.FindOrCreatePlayer(System.UInt32)">
            Find or create a new player.  If the player is new then store the player id in the new player id list.
            
            @param   uint player id
            @return  ksBasePlayer
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.RoomUpdate.SetRoomProperties(System.Collections.Generic.KeyValuePair{System.UInt32,KS.Reactor.ksMultiType}[])" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.RoomUpdate.SetPlayerProperties(KS.Reactor.Client.ksBasePlayer,System.Collections.Generic.KeyValuePair{System.UInt32,KS.Reactor.ksMultiType}[])" -->
        <member name="M:KS.Reactor.Secret.RoomUpdate.SetGravity(KS.Reactor.ksVector3)">
            Store a new gravity value for the room and trip the update gravity flag.
            
            @param   ksVector3 gravity
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddEvent(KS.Reactor.Secret.BaseServerEvent)">
            Store a server event.
            
            @param   BaseServerEvent serverEvent
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.SortEvents">
            Sort the server events.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddOwnerDeltaTime(System.UInt32,System.Single)">
            Adds delta time update from a player who owns entity transforms.
            
            @param   uint ownerId - id of the player this delta time is from.
            @param   float deltaTime - the time in seconds from the owner client that passed between the current entity
                     update we received from them and the one before.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddFailedSpawnId(System.UInt32)">
            <summary>Adds a spawn id to the list of spawn requests that were rejected.</summary>
            <param name="spawnId">Spawn id of spawn that failed.</param>
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.Process">
            Apply all stored updates to the room.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.RemoveSyncGroup(System.UInt32)">
            Add a sync group to the set of all sync groups the user no longer belongs to.
            
            @param   uint Sync group
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.ApplyEntityUpdate(KS.Reactor.Secret.EntityUpdate)">
            <summary>Applies updates to an entity.</summary>
            <param name="update">Entity update data to apply.</param>
        </member>
        <member name="T:KS.Reactor.Secret.RUDPSession.ConnectCallback">
            <summary>
            Callback invoked when the session is established or fails.
            </summary>
            <param name="session"></param>
            <param name="result"></param>
        </member>
        <member name="T:KS.Reactor.Secret.RUDPSession.DisconnectCallback">
            <summary>
            Callback invoked when an established connection disconnects.
            </summary>
            <param name="session"></param>
            <param name="result"></param>
        </member>
        <member name="T:KS.Reactor.Secret.RUDPSession.ReadCallback">
            <summary>
            Callback invoked when a read request has completed reading data from KCP.
            </summary>
            <param name="session"></param>
            <param name="result"></param>
        </member>
        <member name="T:KS.Reactor.Secret.RUDPSession.WriteCallback">
            <summary>
            Callback invoked when a write request is added to the outbound KCP queue.
            </summary>
            <param name="session"></param>
            <param name="result"></param>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.Disconnect(System.Net.Sockets.SocketError)">
            <summary>
            Disconnect. Immmediately stop all aysnc IO operations.
            </summary>
            <param name="error">Reason for the disconnect.</param>
        </member>
        <member name="P:KS.Reactor.Secret.RUDPSession.Id">
            <summary>Session ID</summary>
        </member>
        <member name="P:KS.Reactor.Secret.RUDPSession.IsConnected">
            <summary>Is the stream connection established?</summary>
        </member>
        <member name="P:KS.Reactor.Secret.RUDPSession.IsConnecting">
            <summary>Is the session in the process of establishing the server connection?</summary>
        </member>
        <member name="P:KS.Reactor.Secret.RUDPSession.RemoteEndPoint">
            <summary> Server end point.</summary>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.AsyncConnect(System.Net.EndPoint,KS.Reactor.Secret.RUDPSession.ConnectCallback)">
            <summary>
            Begin an asynchronous connection to a remote server.
            </summary>
            <param name="remoteEndPoint">Remote server end point</param>
            <param name="connectCallback">Callback to invoke when the connetion is established or fails.</param>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.AsyncRead(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.RUDPSession.ReadCallback)">
            <summary>
            Asynchronously read data from the connection.
            </summary>
            <param name="buffer">Buffer to write data to.</param>
            <param name="index">Index in the buffer to write data to.</param>
            <param name="length">Amount of data to read.</param>
            <param name="callback">Callback to invoke when the read request completes.</param>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.AsyncWrite(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.RUDPSession.WriteCallback)">
            <summary>
            Asynchronously write data to the connection.
            </summary>
            <param name="buffer">Buffer to read data from.</param>
            <param name="index">Index in the buffer to read data from.</param>
            <param name="length">Amount of data to write.</param>
            <param name="callback">Callback to invoke when the write request completes.</param>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.HandlePacket(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Handle an UDP packet.  Checks if the packet is a session control packet or a data packet.
            </summary>
            <param name="buffer">Buffer containing the packet</param>
            <param name="index">Index in the buffer where the packet data begins.</param>
            <param name="length">Packet size.</param>
        </member>
        <member name="P:KS.Reactor.Secret.RUDPSession.IsReading">
            <summary>Is an async read request in progress?</summary>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.CompleteRead(System.Net.Sockets.SocketError)">
            <summary>
            Complete an async read request.
            </summary>
            <param name="error">Success or error state of the read request.</param>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.KCPRead">
            <summary>
            Move data from the KCP buffers to async read buffers.
            </summary>
        </member>
        <member name="P:KS.Reactor.Secret.RUDPSession.IsWriting">
            <summary>Is an async write request in progress?</summary>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.CompleteWrite(System.Net.Sockets.SocketError)">
            <summary>
            Complete an async write request.
            </summary>
            <param name="error">Success or error state of the write request.</param>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.KCPWrite">
            <summary>
            Move data from asyn write buffers to the KCP buffers.
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.IsControlPacket(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Check if the buffer contains a session control packet.
            </summary>
            <param name="buffer">Buffer containing the packet</param>
            <param name="index">Index in the buffer where the packet data begins.</param>
            <param name="length">Packet size.</param>
            <returns>True if the buffer is a control packet.</returns>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.HandleControlPacket(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Handle a session control packet.
            </summary>
            <param name="buffer">Buffer containing the packet</param>
            <param name="index">Index in the buffer where the packet data begins.</param>
            <param name="length">Packet size.</param>
            <returns>True if the packet was handled without errors.</returns>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.CompleteConnect">
            <summary>
            Complete the async connection process and create the KCP protocol handler.
            The following are recommended KCP NoDelay flow control rates in millisecons
             normal:  0, 40, 2, 1
             fast:    0, 30, 2, 1
             fast2:   1, 20, 2, 1
             fast3:   1, 10, 2, 1
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.Update">
            <summary>
            Check timeouts, update state, and process data.
            </summary>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.SendControlPacket(KS.Reactor.Secret.RUDPSession.ControlPacketTypes)">
            <summary>
            Send a control packet.
            </summary>
            <param name="type">Control packet type.</param>
        </member>
        <member name="M:KS.Reactor.Secret.RUDPSession.SocketSend(System.Byte[],System.Int32)">
            <summary>
            Write data to the UDP socket.
            </summary>
            <param name="buffer">Data buffer</param>
            <param name="length">Amount of data to write.</param>
        </member>
        <member name="T:KS.Reactor.Secret.ServerEventList">
            Build and process lists of server events.
        </member>
        <member name="M:KS.Reactor.Secret.ServerEventList.#ctor(KS.Reactor.Client.ksBaseRoom)">
            Constructor
            
            @param   ksBaseRoom room
        </member>
        <member name="M:KS.Reactor.Secret.ServerEventList.AddEvent(KS.Reactor.Secret.BaseServerEvent)">
            Add a server event to the list
            
            @param   BaseServerEvent serverEvent
        </member>
        <member name="M:KS.Reactor.Secret.ServerEventList.ProcessEvents">
            Processes the event queue.
        </member>
        <member name="T:KS.Reactor.Secret.BaseServerEvent">
            Base event.  Events are sorted by their ID and are executed based on type
        </member>
        <member name="T:KS.Reactor.Secret.RoomRPCServerEvent">
            Room RPC Event
        </member>
        <member name="T:KS.Reactor.Secret.EntityRPCServerEvent">
            Entity RPC Event
        </member>
        <member name="T:KS.Reactor.Secret.BatchRPCServerEvent">
            Batch RPC Event
        </member>
        <member name="T:KS.Reactor.Secret.DestroyEntityServerEvent">
            Destroy Entity Event
        </member>
        <member name="T:KS.Reactor.Secret.ClientConnectServerEvent">
            Client Connect Event
        </member>
        <member name="T:KS.Reactor.Secret.ClientDisconnectServerEvent">
            Client Disconnect Event
        </member>
        <member name="T:KS.Reactor.Secret.StreamBuffDecoder">
            <summary>Decodes frame data that was encoded using a stream buff encoder.</summary>
        </member>
        <member name="T:KS.Reactor.Secret.StreamBuffDecoder.ControllerIdType">
            <summary>Controller id type.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.StreamBuffDecoder.ControllerIdType.NONE">
            <summary>There is no id because the controller is null.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.StreamBuffDecoder.ControllerIdType.ASSET">
            <summary>The id identifies a controller asset.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.StreamBuffDecoder.ControllerIdType.TYPE">
            <summary>The id identifies a controller type.</summary>
        </member>
        <member name="T:KS.Reactor.Secret.StreamBuffDecoder.EntityPropertyFlags">
            <summary>Flags used for decoding entity properties.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.StreamBuffDecoder.EntityPropertyFlags.NONE">
            <summary>Nothing changed</summary>
        </member>
        <member name="F:KS.Reactor.Secret.StreamBuffDecoder.EntityPropertyFlags.TRANSFORM">
            <summary>Transform permission changed.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.StreamBuffDecoder.EntityPropertyFlags.PROPERTIES">
            <summary>Properties permission changed.</summary>
        </member>
        <member name="F:KS.Reactor.Secret.StreamBuffDecoder.EntityPropertyFlags.OWNER">
            <summary>Owner changed</summary>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodePlayerController(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            <summary>
            Decodes and attaches player controllers to entities and processes input acknowledgements
            </summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of controllers to decode.</param>
            <param name="frameData">Frame data to update.</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeServerEvents(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            <summary>
            Decodes and applies server events such as RPCs and connect/disconnects
            </summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of events to decode.</param>
            <param name="frameData">Frame data to update.</param>
            <param name="syncGroup">Sync group</param>
            <param name="entityArrayManager">Entity array manager</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeClientProperties(System.Byte[],System.Int32,System.UInt32,System.Boolean,KS.Reactor.Secret.RoomUpdate)">
            <summary>Decodes and applies client property updates.</summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of property updates to decode.</param>
            <param name="isFullClientFrame">Is this a full client frame?</param>
            <param name="frameData">Frame data to update.</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeEntityProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            <summary>Decodes and applies entity property updates.</summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of property updates to decode.</param>
            <param name="frameData">Frame data to update.</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeRoomProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            <summary>Decodes and applies room property updates.</summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of property updates to decode.</param>
            <param name="frameData">Frame data to update.</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeOwnerDeltaTimes(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            <summary>Decodes owner delta times.</summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of owner delta times to decode.</param>
            <param name="frameData">Frame data to update.</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeSpawnResponses(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            <summary>Decodes responses to spawn entity requests.</summary>
            <param name="data">Source data</param>
            <param name="offset">Data offset</param>
            <param name="encodedObjectCount">Number of responses to decode</param>
            <param name="frameData">Frame data to update</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            <summary>Decodes new entities. This is not implemented.</summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of entities to decode.</param>
            <param name="frameData">Frame data to update.</param>
            <param name="syncGroup">Sync group</param>
            <param name="entityArrayManager">Entity array manager</param>
        </member>
        <member name="M:KS.Reactor.Secret.StreamBuffDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            <summary>Decodes entity transform updates. This is not implemented.</summary>
            <param name="data">Data to decode.</param>
            <param name="offset">Offset to decode from.</param>
            <param name="encodeObjectCount">Number of entities to decode.</param>
            <param name="frameData">Frame data to update.</param>
            <param name="isSingle">Is this a single or a double delta?</param>
            <param name="syncGroup">Sync group</param>
            <param name="entityArrayManager">Entity array manager</param>
        </member>
        <member name="T:KS.Unity.ksPathFinderAttribute">
            <summary>File and directory path finder attribute tag</summary>
        </member>
        <member name="M:KS.Unity.ksPathFinderAttribute.#ctor(System.Boolean,System.String,System.Boolean)">
            <summary>Constructor</summary>
            <param name="dirOnly">only allow selecting directories.</param>
            <param name="title">title for the file browser.</param>
            <param name="relative">
            if true and the path is in the project, will make the path relative to the
            project.
            </param>
        </member>
        <member name="T:KS.Unity.ksISerializableDictionary">
            <summary>
            Extends the <see cref="T:System.Collections.IDictionary"/> interface with functions used by the dictionary property drawer to detect
            duplicate keys. Because the contents of the dictionary are serialized in a list, it is possible for the list to
            contain duplicate keys.
            </summary>
        </member>
        <member name="M:KS.Unity.ksISerializableDictionary.IsNullOrDuplicateKeyAt(System.Int32)">
            <summary>Checks if the key at the <paramref name="index"/> is null or a duplicate.</summary>
            <param name="index">Index to check.</param>
            <returns>True if the key at the <paramref name="index"/> is null or a duplicate.</returns>
        </member>
        <member name="M:KS.Unity.ksISerializableDictionary.HasDuplicateKeys">
            <summary>Checks if there are any duplicate keys.</summary>
            <returns>True if there are any duplicate keys.</returns>
        </member>
        <member name="M:KS.Unity.ksISerializableDictionary.HasNullKeys">
            <summary>Checks if there are any null keys.</summary>
            <returns>True if there are any null keys.</returns>
        </member>
        <member name="T:KS.Unity.ksSerializableDictionary`2">
            <summary>
            A dictionary that implements <see cref="T:UnityEngine.ISerializationCallbackReceiver"/> for serializing key value data.
            </summary>
        </member>
        <member name="T:KS.Unity.ksSerializableDictionary`2.KeyValue">
            <summary>
            Key/value struct. We define our own struct instead of using KeyValuePair because Unity cannot serialize 
            KeyValuePairs.
            </summary>
        </member>
        <member name="F:KS.Unity.ksSerializableDictionary`2.KeyValue.Key">
            <summary>Key</summary>
        </member>
        <member name="F:KS.Unity.ksSerializableDictionary`2.KeyValue.Value">
            <summary>Value</summary>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.KeyValue.#ctor(`0,`1)">
            <summary>Constructor</summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.Keys">
            <summary>Key collection.</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.Values">
            <summary>Value collection.</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.Count">
            <summary>The number of key/value pairs in the dictionary.</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.IsReadOnly">
            <summary>Is the dictionary read-only?</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Is the dictionary a fixed-size?</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Key collection.</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#Values">
            <summary>Value collection.</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Is the collection thread-safe? See <see cref="P:System.Collections.ICollection.IsSynchronized"/></summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            An object that can be used to synchronize access to the collection. See <see cref="P:System.Collections.ICollection.SyncRoot"/>.
            </summary>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Gets or sets the value associated with a key.</summary>
            <param name="key">Key</param>
            <returns>The value for the key.</returns>
        </member>
        <member name="P:KS.Unity.ksSerializableDictionary`2.Item(`0)">
            <summary>Gets or sets the value associated with a key.</summary>
            <param name="key">Key</param>
            <returns>The value for the key.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.#ctor(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>Constructor</summary>
            <param name="keyValues">Key value pairs to populate the dictionary with.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            <summary>
            Copies all dictionary values into the serialized key/value list if the dictionary is dirty.
            </summary>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            <summary>Copies key and value data from the serialized list into the dictionary.</summary>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.KS#Unity#ksISerializableDictionary#IsNullOrDuplicateKeyAt(System.Int32)">
            <summary>Checks if the key at the <paramref name="index"/> is a duplicate.</summary>
            <param name="index">Index to check.</param>
            <returns>True if the key at the <paramref name="index"/> is a duplicate.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.KS#Unity#ksISerializableDictionary#HasDuplicateKeys">
            <summary>Checks if there are any duplicate keys.</summary>
            <returns>True if there are any duplicate keys.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.KS#Unity#ksISerializableDictionary#HasNullKeys">
            <summary>Checks if there are any null keys.</summary>
            <returns>True if there are any null keys.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.Add(`0,`1)">
            <summary>
            Adds a key/value pair to the dictionary. Throws an exception if the key is already in the dictionary.
            See <see cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)"/>.
            </summary>
            <param name="key">Key to add.</param>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.ContainsKey(`0)">
            <summary>
            Checks if a key is in the dictionary. See <see cref="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)"/>.
            </summary>
            <param name="key">Key to check for.</param>
            <returns>True if the key is in the dictionary.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.ContainsValue(`1)">
            <summary>
            Checks if a value is in the dictionary. See <see cref="M:System.Collections.Generic.Dictionary`2.ContainsValue(`1)"/>.
            </summary>
            <param name="value">Value to check for.</param>
            <returns>True if the value is in the dictionary.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.Remove(`0)">
            <summary>
            Removes a key from the dictionary. See <see cref="M:System.Collections.Generic.Dictionary`2.Remove(`0)"/>.
            </summary>
            <param name="key">Key to remove.</param>
            <returns>
            True if the key was removed from the dictionary. False if the key was not in the dictionary.
            </returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value for a key from the dictionary. See 
            <see cref="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"/>.
            </summary>
            <param name="key">Key to get value for.</param>
            <param name="value">The value for the key.</param>
            <returns>True if the key was in the dictionary.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{Key,Value}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Adds a key/value pair to the dictionary. See <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>.</summary>
            <param name="item">Item to add to the dictionary.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.Clear">
            <summary>Clears the dictionary. See <see cref="M:System.Collections.Generic.Dictionary`2.Clear"/>.</summary>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{Key,Value}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Checks if a key/value pair is in the dictionary. See <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>.
            </summary>
            <param name="item">Item to check for.</param>
            <returns>True if the key/value pair is in the dictionary.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{Key,Value}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the contents of the dictionary to an array. See <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start copying to.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{Key,Value}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes a key/value pair from the dictionary. See <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>.
            </summary>
            <param name="item">Item to remove.</param>
            <returns>True if the key/value pair was removed from the dictionary.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.GetEnumerator">
            <summary>Enumerates the key/value pairs in the dictionary.</summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Enumerates the key/value pairs in the dictionary.</summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds a key/value pair to the dictionary. Throws an exception if the key is already in the dictionary.
            See <see cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)"/>.
            </summary>
            <param name="key">Key to add.</param>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Checks if a key is in the dictionary. See <see cref="M:System.Collections.IDictionary.Contains(System.Object)"/>.</summary>
            <param name="key">Key to check for.</param>
            <returns>True if the key is in the dictionary.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Enumerates the key/value pairs in the dictionary.</summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes a key from the dictionary. See <see cref="M:System.Collections.IDictionary.Remove(System.Object)"/>.</summary>
            <param name="key">Key to remove.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the contents of the dictionary to an array. See <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="index">The index to start copying to.</param>
        </member>
        <member name="T:KS.Unity.ksSerializableHashSet`1">
            <summary>
            A hash set that implements <see cref="T:UnityEngine.ISerializationCallbackReceiver"/> for serializing data.
            </summary>
        </member>
        <member name="P:KS.Unity.ksSerializableHashSet`1.Count">
            <summary>The number of items in the hash set.</summary>
        </member>
        <member name="P:KS.Unity.ksSerializableHashSet`1.IsReadOnly">
            <summary>Is the hash set read-only?</summary>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.Add(`0)">
            <summary>Adds an item to the set.</summary>
            <param name="item">Item to add.</param>
            <returns>True if the item was added. False if it was already in the set.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.Clear">
            <summary>Removes all items from the set.</summary>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.Contains(`0)">
            <summary>Checks if an item is in the set.</summary>
            <param name="item">Item to check for.</param>
            <returns>True if the item is in the set.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the set to an array.</summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Index to begin copying to.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes items in another collection from this set.</summary>
            <param name="other">Items to remove this set.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.GetEnumerator">
            <summary>Iterates the set.</summary>
            <returns>Iterator</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes items from this set that are not in another collection.</summary>
            <param name="other">Items to intersect with.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set is a proper subset of another collection, meaning all of the items in this set are in
            the other collection and the other collection contains at least one item that is not in the set.
            </summary>
            <param name="other">Items to check if is this is a proper subset of.</param>
            <returns>True if this is a proper subset of the other items.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set is a proper superset of another collection, meaning all of the items in the other
            collection are in this set and this set contains at least one item that is not in the other collection.
            </summary>
            <param name="other">Items to check if is this is a proper superset of.</param>
            <returns>True if this is a proper superset of the other items.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set is a subset of another collection, meaning all of the items in this set are in the other
            collection.
            </summary>
            <param name="other">Items to check if is this is a subset of.</param>
            <returns>True if this is a subset of the other items.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set is a superset of another collection, meaning all of the items in the other collection
            are in this set.
            </summary>
            <param name="other">Items to check if is this is a superset of.</param>
            <returns>True if this is a superset of the other items.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Checks if any of the items in another collection are in this set.</summary>
            <param name="other">Items to check for.</param>
            <returns>True if any of the items are in this set.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.Remove(`0)">
            <summary>Removes an item from the set.</summary>
            <param name="item">Item to remove.</param>
            <returns>True if the item was removed. False if it was not in the set.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set and another collection contain all the same items.
            </summary>
            <param name="other">Items to check for.</param>
            <returns>True if this set contains exactly the same items as <paramref name="other"/>.</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items from this set that are in <see cref="!:other"/>, and adds items from <see cref="!:other"/> that
            are not in this set.
            </summary>
            <param name="other">Other items to symmetric except with.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Adds items to this set.</summary>
            <param name="other">Items to add.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>Adds an item to the set.</summary>
            <param name="item">Item to add.</param>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Iterates the set.</summary>
            <returns>Iterator</returns>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            <summary>Copies items from the set into the serialized list if the set is dirty.</summary>
        </member>
        <member name="M:KS.Unity.ksSerializableHashSet`1.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            <summary>Copies items from the list into the set.</summary>
        </member>
        <member name="T:KS.Compression.BaseEncoderModel">
            Base class for all encoder models.
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.CompressorId">
             Returns a byte id of the compressor that uses this model.
            
             @return   byte id unique to the compressor
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.Version">
             Returns the version of the compressor
            
             @return   ushort version of the compressor
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.Serialize(System.IO.BinaryWriter)">
             Serializes the model.
            
             @param   BinaryWriter writer
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.Deserialize(System.Byte[])">
             Deserializes the model.
             The model data must starts with 7 byte header data:
             byte compressor Id
             uin16_t version
             uint length
            
             @param   byte[] modelData
             @return  bool - true if the model is set successfully
        </member>
        <member name="T:KS.Compression.BFEncoderModel">
            This class contains the probabilities used in the binary flag encoder/decoder.
            It also tracks the stats to generate the dynamic model.
        </member>
        <member name="M:KS.Compression.BFEncoderModel.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BFEncoderModel.#ctor(KS.Compression.BFEncoderModel)">
             Copy constructor
            
             @param   BFEncoderModel model to copy from
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Finalize">
            Destructor.
        </member>
        <member name="M:KS.Compression.BFEncoderModel.CompressorId">
             Returns a byte id of the compressor that uses this model.
            
             @return   byte id unique to the compressor
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Version">
             Returns the version of the compressor
            
             @return   ushort version of the compressor
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Serialize(System.IO.BinaryWriter)">
             Serializes the model.
            
             @return  BinaryWriter writer
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Deserialize(System.Byte[])">
             Deserializes the model.
             The model data byte array contains:
             8 probabilities for the full object flag bits
             58 probabilities for the update object flag bits
             2 probabilities for the object flag bit
             24 probabilities for the sign bits
             Each probability is stored as a uint. Therefore the model data should contains 368 bytes.
            
             @param   byte[] modelData
             @return  bool - true if the model is set successfully
        </member>
        <member name="M:KS.Compression.BFEncoderModel.DeserializeFullObjectModel(System.Byte[],System.Int32@)">
             Decode the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Compression.BFEncoderModel.DeserializeUpdateObjectModel(System.Byte[],System.Int32@)">
             Decode the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Compression.BFEncoderModel.ComputeProbabilities(System.Boolean)">
             Computes probabilities from the stats.
            
             @param   bool isFullObject
        </member>
        <member name="M:KS.Compression.BFEncoderModel.ComputeProbability(System.Int64,System.Int64)">
             Computes a probability from the given total bit count and one bit count.
            
             @param   long totalBitCount
             @param   long oneBitCount
             @return  uint probability
        </member>
        <member name="M:KS.Compression.BFEncoderModel.AddFullStats(KS.Compression.BFModelStats)">
             Adds the given full object stats.
            
             @param   BFModelStats fullFlagStats
        </member>
        <member name="M:KS.Compression.BFEncoderModel.AddUpdateStats(KS.Compression.BFModelStats,KS.Compression.BFModelStats)">
             Adds the given update object stats.
            
             @param   BFModelStats updateFlagStats
             @param   BFModelStats signBitsStats
        </member>
        <member name="T:KS.Compression.BFModelStats">
            Tracks the stats that are used to generate the binary flag model.
        </member>
        <member name="M:KS.Compression.BFModelStats.#ctor(System.UInt32)">
             Constructor
            
             @param   uint size of stats array
        </member>
        <member name="M:KS.Compression.BFModelStats.ClearStats">
            Clears the stats.
        </member>
        <member name="M:KS.Compression.BFModelStats.Add(KS.Compression.BFModelStats)">
             Adds the given stats to these stats.
            
             @param   BFModelStats stats
        </member>
        <member name="M:KS.Compression.BFModelStats.Subtract(KS.Compression.BFModelStats)">
             Subtracts the given stats from these stats.
             If the values in the given stats is bigger than these stats', set the values to 0.
            
             @param   BFModelStats stats
        </member>
        <member name="M:KS.Compression.BFModelStats.Deserialize(System.Byte[],System.Int32@)">
             Decode the stats.
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Compression.BinArithCoder">
            Binary arithmetic coder base class.
            Common methods, constants and data as used for encoding and decoding of binary
            arithmetic stream.
        </member>
        <member name="M:KS.Compression.BinArithCoder.ClampProb(System.UInt32)">
             Returns a clamped value that is greater than zero and less than kProbMax.
            
             @param   uint prob
             @return  uint
        </member>
        <member name="T:KS.Compression.BinArithDecoder">
            Binary arithmetic decoder (Ilya Muravyov's variant).
            Decodes a string of binary (0/1) events with probabilities that are not 1/2.
            This code is written for clarity, not performance.
        </member>
        <member name="M:KS.Compression.BinArithDecoder.GetByte">
             Gets the next byte of data to decode.
            
             @return  byte
        </member>
        <member name="M:KS.Compression.BinArithDecoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinArithDecoder.Initialize(System.IO.BinaryReader)">
             Initialize
            
             @param   BinaryReader source - data to decode
        </member>
        <member name="M:KS.Compression.BinArithDecoder.Decode(System.UInt32)">
             Decodes a binary symbol with the probability of a 1 being "prob".
            
             @param   uint prob to decode the next bit with
             @return  int - decoded bit
        </member>
        <member name="M:KS.Compression.BinArithDecoder.DecodeWithBitSwitchProb(System.Int32,System.UInt32)">
             Decodes with the given bit as the context. If the context bit is zero,
             use the given probability. Otherwise, use kProbMax - prob.
            
             @param   int context bit
             @param   uint prob
             @return  int - decoded bit
        </member>
        <member name="T:KS.Compression.BinArithEncoder">
            Binary arithmetic encoder (Ilya Muravyov's variant).
            Encodes a string of binary (0/1) events with probabilities that are not 1/2.
            This code is written for clarity, not performance.
        </member>
        <member name="M:KS.Compression.BinArithEncoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinArithEncoder.Initialize(System.IO.BinaryWriter)">
             Initialize
            
             @param    BinaryWriter  target - buffer to encode data to
        </member>
        <member name="M:KS.Compression.BinArithEncoder.Written">
            Get the number of written bytes
            
            @return  int  bytes written
            
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.BinArithEncoder.Encode(System.Int32,System.UInt32)" -->
        <member name="M:KS.Compression.BinArithEncoder.EncodeWithBitSwitchProb(System.Int32,System.Int32,System.UInt32)">
             Encodes the given bit with another bit as the context. If the context bit is zero,
             use the given probability. Otherwise, use kProbMax - prob.
            
             @param   int bit to encode
             @param   int context bit
             @param   uint prob
        </member>
        <member name="M:KS.Compression.BinArithEncoder.Flush">
            Finish encoding. Flushes remaining codeword.
        </member>
        <member name="T:KS.Compression.BinaryFlagDecoder">
            Decoder for data encoded by BinaryFlagEncoder.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.SetStaticModel(System.Byte[])">
            Sets the static model.
            
            @param   byte[] modelData
            @return  bool true if the static model was set successfully
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.SetUseStaticModel(System.Boolean,System.Boolean)">
            Toggles using static model for decoding full objects and update objects.
            
            @param   bool useForFullObject
            @param   bool useForUpdateObject
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.Initialize(KS.Compression.EncodedData,System.Boolean)">
            Initializes the data structures required to decode data
            
            @param   EncodedData encodedData
            @param   bool useDefaultModel
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.Decode">
            Decodes encoded data.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeObject(System.Int32,System.UInt32[0:,0:])">
             Decodes the object at the given index.
            
             @param   int objectIndex
             @param   uint[,] signBitProbsWithContext
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeFullObjectFlags">
            Decode full object flags.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeFieldBitSizes">
            Decode field sizes.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeUpdateObjectFlags">
            Decode update object flags.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeUpdateObjectFieldFlags(System.Int32@,System.Boolean,System.UInt32[])">
             Decodes update object field flags.
            
             @param   ref int flagBitIndex
             @param   bool skipFieldBit - if true, skip decoding of the bit for the field
             @param   uint[] updateObjectFlagBitProbs
             @return  byte flag
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DeserializeFullObjectModel(System.Byte[],System.Int32@)">
             Deserializes the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DeserializeUpdateObjectModel(System.Byte[],System.Int32@)">
             Deserializes the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Compression.BinaryFlagEncoder">
            This encoder generates flags for fields to indicate if they are zero, then uses binary arithmetic encoding to
            encode the objects by columns with the probabilities of bit switching for each column.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.SetStaticModel(System.Byte[])">
            Sets the static model.
            
            @param   byte[] modelData
            @return  bool true if the static model was set successfully
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.SetUseStaticModel(System.Boolean,System.Boolean)">
            Toggles using static model for encoding full objects and update objects.
            
            @param   bool useForFullObject
            @param   bool useForUpdateObject
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.Initialize(KS.Compression.EncodedData,System.Boolean)">
             Initializes
            
             @param   EncodedData encodedData
             @param   bool useDefaultModel
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.GenerateFlags">
            Generates flags.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.Encode">
            Encodes raw data.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeObject(System.Int32,System.UInt32[0:,0:])">
             Encodes the object at the given index.
            
             @param   int objectIndex
             @param   uint[,] signBitProbsWithContext
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeFullObjectFlags">
            Encodes full object flags.
            Full object flag uses 8 bits:
            1 bit for the position. 1 bit for each position element.
            1 bit for the rotation. 1 bit for each rotation element.
            If the position or rotation bit is 0, then we don't encode the bits for the position or rotation elements,
            otherwise at least one element bit has to be 1.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeFieldBitSizes">
            Encodes field sizes. It uses 6 bits to store the maximum bit size of the biggest value of a field.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeUpdateObjectFlags">
            Encodes update object flags.
            Update object's flag uses 58 bits: 1 bit for the object.
            For each transform vector(position, rotation and scale):
            1 bit for the vector, 1 bit for each vector element, 5 bits for the field size.
            If the object bit is 0, then we just encode this 0 bit.
            Otherwise, if the vector bit is 0, then we encode the vector bit but not the element bits.
            If the vector bit is 1, then at least one vector element bit has to be 1.
            If the vector element bit is 0, then we don't encode the field size.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeUpdateObjectFieldFlags(System.Byte,System.Int32@,System.Boolean,System.UInt32[])">
             Encodes update object field flags.
             Encodes the bit for the field first. If it is not 0, encodes the field size.
            
             @param   byte flag
             @param   ref int flagBitIndex
             @param   bool skipFieldBit - if true, don't encode the bit for the field
             @param   uint[] updateObjectFlagBitProbs
             @return  bool - true if the field bit is 0
        </member>
        <member name="T:KS.Compression.EncodedData">
            Class used for tracking encoded data
        </member>
        <member name="M:KS.Compression.EncodedData.#ctor">
            Constructor
        </member>
        <member name="T:KS.Compression.FieldFlag">
            This class generates and encodes/decodes flags indicating if each field(position, rotation, scale) is zero.
        </member>
        <member name="M:KS.Compression.FieldFlag.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.FieldFlag.Initialize(System.Int32,System.Int32)">
             Initialize
            
             @param   int objSize
             @param   int objCount
        </member>
        <member name="M:KS.Compression.FieldFlag.IsZeroField(System.Int32,System.Int32)">
             Checks if the field starts at the given byte is zero.
            
             @param   int objIndex
             @param   int byteIndex
             @return  true if the field is zero
        </member>
        <member name="M:KS.Compression.FieldFlag.GetFieldSize(System.Int32,System.Int32)">
             Gets field size.
            
             @param   int objIndex
             @param   int byteIndex
             @return  byte field size
        </member>
        <member name="M:KS.Compression.FieldFlag.SkipUpdateObject(System.Int32)">
             Checks if we can skip the given update object for encoding.
            
             @param   int objIndex
             @return  true if we can skip this object
        </member>
        <member name="T:KS.Compression.FieldFlagGenerator">
            This class generates the field flags indicating if each field(position, rotation, scale) is zero.
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateFullObjectFlags(KS.Compression.FieldFlag,System.IO.BinaryReader)">
             Generates field bit sizes and fields flags for the full object data.
            
             @param   FieldFlag fieldFlag
             @param   BinaryReader srcData
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateUpdateObjectFlags(KS.Compression.FieldFlag,System.IO.BinaryReader)">
             Generates field bit sizes and fields flags for the update object data.
            
             @param   FieldFlag fieldFlag
             @param   BinaryReader srcData
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateTransformFlags(KS.Compression.FieldFlag,System.Int32,System.IO.BinaryReader)">
             Generates flags for the position or the rotation or the scale.
            
             @param   FieldFlag fieldFlag
             @param   int flagIndex
             @param   BinaryReader data
             @param   ref int position
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateFieldFlags(KS.Compression.FieldFlag,System.Int32,System.IO.BinaryReader)">
             Generates flag for the given field data.
             We use 1 bit for the field not being zero and 5 bits for the field bit size.
            
             @param   FieldFlag fieldFlag
             @param   int flagIndex
             @param   BinaryReader data
             @param   int position
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GetMostSignificantBitIndex(System.UInt32)">
             Gets the index of the most significant bit of a uint.
            
             @param   uint value
             @return  byte index
        </member>
        <member name="M:KS.Compression.FLBinaryTreeDecoder.ReverseDiff">
            Perform a reverse diff(replace different bits) from the encoded array to the data array
        </member>
        <member name="M:KS.Compression.FLByteDiffDecoder.ReverseDiff">
            Perform a reverse diff(replace different bytes) from the encoded array to the data array
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLDecoder.Initialize(System.Byte[],System.Collections.Generic.List{System.UInt32},System.Int32,System.Int32,System.Byte[]@)" -->
        <member name="M:KS.Compression.FLDecoder.ReverseDiff">
            Perform a reverse diff(sequential additions) from the encoded array to the data array
        </member>
        <member name="M:KS.Compression.FLDecoder.DecompressDelta(System.Int32,System.Byte[])">
             Compress and copy the delta and its length (max 255 bytes) to the destination
            
             @param   int index offset in bytes to the header for the next expected delta
             @param	byte[] delta data
             @return	int index to the next delta location
        </member>
        <member name="M:KS.Compression.FLDecoder.ReverseApplyModel(System.Int32)">
             Copy remapped bits from the source object to the destination object
            
             @param   int index of the start byte of the target object to remap
        </member>
        <member name="M:KS.Compression.FLDecoder.GetDecoderTasks(System.Int32)">
            Generate a queue of concurrent tasks for decoding.
            
            @param   int taskCount number of tasks to generate
            @return  DecoderTask[] list of tasks that can be executed concurrently
        </member>
        <member name="M:KS.Compression.FLDecoder.InitializeBitCounts">
            Initialize bit counts.
        </member>
        <member name="M:KS.Compression.FLDecoder.GetBitCounts">
            Return bit counts
            
            @return  uint[]
        </member>
        <member name="P:KS.Compression.FLEncoder.Deltas">
            Encoded deltas
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoder.Initialize(System.Collections.Generic.List{System.UInt32},System.Int32,System.Int32,System.Byte[])" -->
        <member name="M:KS.Compression.FLEncoder.ApplyModel(System.Int32)">
             Copy remapped bits from the source object to the destination object
            
             @param	int index of the target object for bit remapping
        </member>
        <member name="M:KS.Compression.FLEncoder.GetEncoderTasks(System.Int32)">
            Generate a queue of concurrent tasks for encoding.
            
            @param taskCount number of tasks tp generate
        </member>
        <member name="M:KS.Compression.FLEncoder.Sort">
            Sort the object indices
        </member>
        <member name="M:KS.Compression.FLEncoder.Diff">
            Calculate and store the difference between each sorted object
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoder.Subtract(System.Int32,System.Int32,System.Byte[])" -->
        <member name="M:KS.Compression.FLEncoder.CompressDelta(System.Byte[])">
             Compress and copy the delta and its length (max 255 bytes) to the destination
            
             @param	byte[] delta
             @return	int number of bytes the delta was written as (includes size byte)
        </member>
        <member name="T:KS.Compression.FLEncoderModel">
            Generates the model for fixed-length object encoder.
            The model is a remapping of bits, where the bits are 
            remapped from most significant to least significant
            (little-endian), ordered by lowest variance to highest, 
            then by lowest mean to highest
        </member>
        <member name="T:KS.Compression.FLEncoderModel.BitStats">
            Structure that stores bit statistics
        </member>
        <member name="P:KS.Compression.FLEncoderModel.SerializedModel">
            Get/Set the serialized model data
        </member>
        <member name="M:KS.Compression.FLEncoderModel.#ctor">
            Construct a new FLEncoderModel and assign the default model.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoderModel.SetModelData(System.Collections.Generic.List{System.UInt32})" -->
        <member name="M:KS.Compression.FLEncoderModel.Initialize(System.Byte[],System.Int32,System.Int32)">
            Initializes the model. 
            
            @param   byte[] sourceData byte array containing source data?
            @param   int objSize the size of the objects to analyze
            @param   int objCount the number of objects to analyze
        </member>
        <member name="M:KS.Compression.FLEncoderModel.GetModelTasks(System.Int32)">
            Create a list of tasks that can be run concurrently
            
            @param   int taskCount number of tasks to generate.
        </member>
        <member name="M:KS.Compression.FLEncoderModel.CountBits(System.Int32)">
             Add the bits from an object to the bit count totals
            
             @param	int byteOffset offset of the object data to analyze
        </member>
        <member name="M:KS.Compression.FLEncoderModel.CountBitsByNibble(System.Byte,System.Int32)">
             Examine the 4 lowest bits of a byte and add them to the bit count total
            
             @param	byte nibble data to analyze
             @param	int bitOffset location of bit counter
        </member>
        <member name="M:KS.Compression.FLEncoderModel.BuildModel">
            Construct a model from the bit counts
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoderModel.GetModel" -->
        <member name="M:KS.Compression.FLEncoderModel.SerializeModel">
            Serializes the model.
        </member>
        <member name="M:KS.Compression.FLEncoderModel.DeserializeModel(System.Boolean)">
            Deserialize the model.
        </member>
        <member name="M:KS.Compression.FLEncoderModel.DeserializeModelData(System.Byte[],System.Int32@)">
            Deserialize model data from a source buffer.
            
            @param   byte[] - model data buffer
            @para    ref int - offset
        </member>
        <member name="M:KS.Compression.FLEncoderModel.ParseModelData(System.Byte[])">
            Parse and construct a model object from a byte buffer
            
            @param   byte[] - model data buffer
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoderModel.InsertBitposToFront(System.Collections.Generic.List{System.UInt32})" -->
        <member name="M:KS.Compression.FLEncoderModel.SetBitCounts(System.UInt32[])">
            Set bit counts.
            
            @param   uint[] bitCounts
        </member>
        <member name="M:KS.Compression.FLEncoderModel.ReadUInt32(System.Byte[],System.Int32@,System.UInt32)">
            Read uint from src starting from index with length
            @param	byte[] src - source byte array
            @param	ref int index of starting position
            @param	uint length of data to read
            @return  uint value read out
        </member>
        <member name="M:KS.Compression.FLEncoderModel.WriteBytes(System.Byte[],System.UInt32,System.UInt32,System.Int32@)">
            Writes up to 4 bytes into a byte array.
            
            @param   byte[] dest to write to.
            @param   uint value to write.
            @param   uint numBytes to write.
            @param   ref int index to write to. Will be increased by the number of bytes written.
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder">
            Decodes object diffs with probabilities generated from the last row.
            Returns the decoded data as a byte vector.
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder.ReverseDiffFunction">
             Object reverse diff callback.
            
             @param   BinaryReader x - reader of the object diff data
             @param   BinaryReader y - reader of the object to apply diff data
             @param   BinaryWriter dest - writer of the result object
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder.DecodeFunction">
             Object decoding callback.
            
             @param   BinArithDecoder decoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader context
             @param   BinaryReader decoded
             @param   int length
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder.DecodeParams">
            Class of the decoding parameters.
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.DecodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
             Constructor
            
             @param   byte[] encoded
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.DecodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,KS.Compression.Object2dArrayDecoder.ReverseDiffFunction,KS.Compression.Object2dArrayDecoder.DecodeFunction)">
             Constructor
            
             @param   byte[] encoded
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
             @param   int diffObjectSize
             @param   int bitNumberToDecodePerObject
             @param   ReverseDiffFunction reverseDiffFunction
             @param   DecodeFunction decodeFunction
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.Decode(KS.Compression.Object2dArrayDecoder.DecodeParams)">
             Decodes data with the given params.
            
             @param   DecodeParams decodeParams
             @return  byte[] - decoded data
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.ReverseDiff(KS.Compression.Object2dArrayDecoder.DecodeParams,System.Byte[])">
             Iterate through all object diffs and call decodParams.ReverseDiff on them to get the original object data.
            
             @param   DecodeParams decodeParams
             @param   byte[] decodedData
        </member>
        <member name="T:KS.Compression.ReverseDiffFunctions">
            This class contains the reverse diff functions for different data structures.
        </member>
        <member name="M:KS.Compression.ReverseDiffFunctions.Xor(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Performs an XOR of all bytes on object x with object y and store the results in object dest.
            
             @param   BinaryReader x - reader of the object diff data
             @param   BinaryReader y - reader of the object to apply diff data
             @param   BinaryWriter dest - writer of the result object
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.ReverseDiffFunctions.ReverseDiffSingleFloatComponents(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Combines the mantissa, exponent, and sign components of all floats in object x with object y
             and store the results in object dest.
            
             @param   BinaryReader x - reader of the object diff data
             @param   BinaryReader y - reader of the object to apply diff data
             @param   BinaryWriter dest - writer of the result object
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.DecodeFunctions">
            This class contains the decode functions for different data structures.
        </member>
        <member name="M:KS.Compression.DecodeFunctions.DecodeAllBits(KS.Compression.BinArithDecoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Decodes the given length of data bit by bit.
            
             @param   BinArithDecoder decoder to decode the encoded bits
             @param   uint[] probs - probabilities to decode bits
             @param   int[] bitSwitchCount - record bit switch count to compute probabilities
             @param   BinaryReader context - context data used to switch probabilities
             @param   BinaryWriter decoded - output writer for the decoded data
             @param   int length
        </member>
        <member name="M:KS.Compression.DecodeFunctions.DecodeSingleFloatComponents(KS.Compression.BinArithDecoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Decodes mantissa diff, exponent diff and sign diff.
            
             @param   BinArithDecoder decoder to decode the encoded bits
             @param   uint[] probs - probabilities to decode bits
             @param   int[] bitSwitchCount - record bit switch count to compute probabilities
             @param   BinaryReader context - context data used to switch probabilities
             @param   BinaryWriter decoded - output writer for the decoded data
             @param   int length
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder">
             This encoder encodes with the given EncodeParams.
             - EncodeParams.Source and EncodeParams.SourceLength defines the byte array of the source data.
             - With the EncodeParams.RowCount, EncodeParams.ColumnCount and EncodeParams.ObjectSize, the encoder can
               interpret the source data as a 2d object array.
             - The Diff function computes the diff between two objects and output a diff object of DiffObjectSize.
             - The Encode function encodes the diff data.
            
             The encoder encodes the objects in two steps:
             1. Diff. It diffs each object in the first column with the object in the last row, each object in the remaining
             columns with the object in the last column.
             2. Encode. It encodes each object with the probabilities generated from the last row. There is one probability
                for every bit need to encode for an object. It is the probability of the bit in the current object being
                different from the bit of the object in the last row or column. The very first object is encoded as it is
                since it has no object to diff with.
             The encoded data will be returned as a byte vector.
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder.DiffFunction">
             Object diff callback.
            
             @param   BinaryReader x - reader of the object to diff
             @param   BinaryReader y - reader of the object to diff with
             @param   BinaryWriter dest - writer of the diff data
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder.EncodeFunction">
             Object encoding callback.
            
             @param   BinArithEncoder encoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader source
             @param   BinaryReader context
             @param   int length
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder.EncodeParams">
            Class of the encoding parameters.
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.EncodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
             Constructor
            
             @param   byte[] source
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.EncodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,KS.Compression.Object2dArrayEncoder.DiffFunction,KS.Compression.Object2dArrayEncoder.EncodeFunction)">
             Constructor
            
             @param   byte[] source
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
             @param   int diffObjectSize
             @param   int bitNumberToEncodePerObject
             @param   DiffFunction diffFunction
             @param   EncodeFunction encodeFunction
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.Encode(KS.Compression.Object2dArrayEncoder.EncodeParams)">
             Encodes data with the given params.
            
             @param   EncodeParams encodeParams
             @return  byte[] - encoded data
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.Diff(KS.Compression.Object2dArrayEncoder.EncodeParams)">
             For the first column, diff the object with the one in the last row.
             For other columns, diff the object with the one in the last column.
            
             @param   EncodeParams encodeParams
        </member>
        <member name="T:KS.Compression.DiffFunctions">
            This class contains the diff functions for different data structures.
        </member>
        <member name="M:KS.Compression.DiffFunctions.Xor(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Performs an XOR of all bytes on object x with object y and store the results in object dest.
            
             @param   BinaryReader x - reader of the object to diff
             @param   BinaryReader y - reader of the object to diff with
             @param   BinaryWriter dest - writer of the diff data
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.DiffFunctions.DiffSingleFloatComponent(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Generates a difference of the mantissa, exponent, and sign components of all floats in object x with
             object y and store the results in object dest.
            
             @param   BinaryReader x - reader of the object to diff
             @param   BinaryReader y - reader of the object to diff with
             @param   BinaryWriter dest - writer of the diff data
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.EncodeFunctions">
            This class contains the encode functions for different data structures.
        </member>
        <member name="M:KS.Compression.EncodeFunctions.EncodeAllBits(KS.Compression.BinArithEncoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryReader,System.Int32)">
             Encodes the given data bit by bit.
            
             @param   BinArithEncoder encoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader source
             @param   BinaryReader context
             @param   int length
        </member>
        <member name="M:KS.Compression.EncodeFunctions.EncodeSingleFloatComponents(KS.Compression.BinArithEncoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryReader,System.Int32)">
             Encodes mantissa diff, exponent diff and sign diff data.
            
             @param   BinArithEncoder encoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader source
             @param   BinaryReader context
             @param   int length
        </member>
    </members>
</doc>
